{"version":"1","records":[{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook"},"content":" \n\n\n\n\n\n\n\n\n\nThis Cookbook is a comprehensive showcase of workflows & techniques for visualizing Unstructured Grids using \n\nUXarray,\nalso providing foundational information on unstructured grids.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Motivation"},"type":"lvl2","url":"/#motivation","position":2},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Motivation"},"content":"The ability to natively visualize unstructured grids is much needed within the Scientific Python Ecosystem,\nwhich poses multiple challenges and needs to:\n\nNot regrid the source unstructured grid to structured grid\n\nTake advantage of grid information, such as connectivity variables\n\nLimit the amount of pre-processing needed to prepare the data for Python visualization tools\n\nUXarray enables such visualization methods that operate directly on unstructured grid data, providing\nXarray-styled functionality to better read in and use unstructured grid datasets that follow standard\nconventions.\n\nUXarray supports a variety of unstructured grid formats and file types including UGRID, MPAS, ICON, CAM-SE,\nSCRIP, Exodus, ESMF, GEOS, and FESOM2, and is extensible for other formats.\n\nThis cookbook covers an introduction to unstructured grids and UXarray from a visualization standpoint,\nproviding foundational information about unstructured grids, visualization methods and libraries, and\nintroducing UXarray, and showcasing several UXarray visualization functions and workflows.","type":"content","url":"/#motivation","position":3},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":4},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Authors"},"content":"Philip Chmielowiec (NSF NCAR)\n\nOrhan Eroglu (NSF NCAR)\n\nRajeev Jain (Argonne National Laboratory)\n\nIan Franda (University of Wisconsin-Madison)\n\nRachel Tam (University of Illinois Urbana-Champaign)","type":"content","url":"/#authors","position":5},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":6},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":7},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":8},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Structure"},"content":"This cookbook is split up into several chapters to communicate the content efffectively with different\nlevels of readers:\n\n1. Foundations\n\nHere, we cover overview of the foundational topics necessary to understand the content in this cookbook,\ne.g. what unstructured grids are and how they are different than structured grids, what plotting libraries\nand visualization techniques exist that can be helpful for unstructured grid visualization, and we briefly\nmention how UXarray is related to these.\n\n2. Introduction to UXarray\n\nIn this chapter, we provide an overview of UXarray: An Xarray-extension for unstructured grid-formatted\nclimate and global weather data analysis and visualization.\n\n3. Plotting with UXarray\n\nWe provide an overview of the UXarray plotting API along with several visualization functionality, and cases\nand examples that can be realized using such UXarray functionality; Grid visualization, Data visualization,\nGeographic projections and features, to name a few. Also in this section, customization and interactivaity\nwith UXarray plotting and considerations with high-resolution plotting are also provided.\n\n4. Visualization Recipies\n\nIn this last chapter, we offer to the interested readers a set of focused workflows that can be realized\nwith UXarray, including visualizations of MPAS and E3SM model output.","type":"content","url":"/#structure","position":9},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":10},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder or on your local machine.","type":"content","url":"/#running-the-notebooks","position":11},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":12},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\n“launch Binder”. After a moment you should be presented with a\nnotebook that you can interact with. I.e. you’ll be able to execute\nand even change the example programs. You’ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.","type":"content","url":"/#running-on-binder","position":13},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":14},{"hierarchy":{"lvl1":"Unstructured Grid Visualization Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your computer, you will need to follow this workflow:\n\nClone the https://github.com/ProjectPythia/unstructured-grid-viz-cookbook repository: git clone https://github.com/ProjectPythia/unstructured-grid-viz-cookbook.git\n\nMove into the unstructured-grid-viz-cookbook directorycd unstructured-grid-viz-cookbook\n\nCreate and activate your conda environment from the environment.yml fileconda env create -f environment.yml\nconda activate unstructured-grid-viz-cookbook-dev\n\nMove into the notebooks directory and start up Jupyterlabcd notebooks/\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":15},{"hierarchy":{"lvl1":"Plotting Libraries"},"type":"lvl1","url":"/notebooks/foundations/plotting-libs","position":0},{"hierarchy":{"lvl1":"Plotting Libraries"},"content":"","type":"content","url":"/notebooks/foundations/plotting-libs","position":1},{"hierarchy":{"lvl1":"Plotting Libraries"},"type":"lvl1","url":"/notebooks/foundations/plotting-libs#plotting-libraries","position":2},{"hierarchy":{"lvl1":"Plotting Libraries"},"content":"","type":"content","url":"/notebooks/foundations/plotting-libs#plotting-libraries","position":3},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"In this section, you’ll learn:"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#in-this-section-youll-learn","position":4},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"In this section, you’ll learn:"},"content":"What general purpose visualization packages are available in the Scientific Python Ecosystem\n\nHow functionality of these packages can be useful for unstructured grids visualization","type":"content","url":"/notebooks/foundations/plotting-libs#in-this-section-youll-learn","position":5},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#related-documentation","position":6},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Related Documentation"},"content":"No UXarray documentation is referenced here since this section covers the content from a general point of view.","type":"content","url":"/notebooks/foundations/plotting-libs#related-documentation","position":7},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#prerequisites","position":8},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nPython\n\nNecessary\n\nThis notebook does not contain any Python code, but understanding those libraries comprehensively would require Python programming\n\nTime to learn: 10 minutes\n\nIn this section, we will introduce two visualization libraries/technologies and their features and functionality that can be useful for unstructured grids visualization before diving deep into plotting unstructured grids with UXarray in the next chapter.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#prerequisites","position":9},{"hierarchy":{"lvl1":"Plotting Libraries","lvl2":"HoloViz"},"type":"lvl2","url":"/notebooks/foundations/plotting-libs#holoviz","position":10},{"hierarchy":{"lvl1":"Plotting Libraries","lvl2":"HoloViz"},"content":"\n\nHoloViz is a stack of tools (such as Holoviews, Datashader, Geoviews, SpatialPandas, hvPlot etc.) that provide high-level functionality to visualize even the very large datasets efficiently in Python. HoloViz packages are well-suited for unstructured grid visualization because:\n\nThey provide rendering functionality for both vector geometries and rasterization, which will be detailed in the \n\nnext section. Such functionality is much needed for unstructured grid topology and data visualization purposes.\n\nUnlike Matplotlib, they support using the connectivity information that comes from the unstructured grids\n\nThey are designed to be scalable for even the largest datasets that’d be generated as result of kilometer-scale analyses\n\nLet us look at the particular HoloViz packages that can be useful for scalable visualization of unstructured grids.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#holoviz","position":11},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"HoloViews","lvl2":"HoloViz"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#holoviews","position":12},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"HoloViews","lvl2":"HoloViz"},"content":"Holoviews houses several elements (e.g. Path(), Points()) that enables visualization of grid geometries such as nodes and edges. Similarly, other elements of this package (e.g. Polygons()) can be used for various polygon vector visulization purposes.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#holoviews","position":13},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Datashader","lvl2":"HoloViz"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#datashader","position":14},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Datashader","lvl2":"HoloViz"},"content":"\n\nDatashader is the graphics pipeline system of the HoloViz tool stack for creating meaningful representations of large datasets quickly and flexibly. Datashader’s rasterization methods, transfer functions, and other shading operators can be utilized for rasterized polygon plotting.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#datashader","position":15},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"GeoViews","lvl2":"HoloViz"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#geoviews","position":16},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"GeoViews","lvl2":"HoloViz"},"content":"\n\nGeoViews provides features and functionality to visualize geographical, meteorological, and oceanographic datasets and features.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#geoviews","position":17},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Spatialpandas","lvl2":"HoloViz"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#spatialpandas","position":18},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Spatialpandas","lvl2":"HoloViz"},"content":"\n\nSpatialpandas is a package that provides Pandas extension arrays for spatial/geometric operations. This package has an element called GeoDataFrame, which can be used directly by packages from the HoloViz stack such as hvPlot, Datashader, Holoviews, and Geoviews. Conversions from unstructured grids to GeoDataFrame can allow to perform visualizations directly in HoloViz packages.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#spatialpandas","position":19},{"hierarchy":{"lvl1":"Plotting Libraries","lvl2":"Matplotlib"},"type":"lvl2","url":"/notebooks/foundations/plotting-libs#matplotlib","position":20},{"hierarchy":{"lvl1":"Plotting Libraries","lvl2":"Matplotlib"},"content":"\n\nMatplotlib is the workhorse of Python visualization needs, for both general and geoscientific purposes. However, when it\ncomes to visualizing unstructured grids, Matplotlib’s:\n\nFunctionality is limited such that there is no way to use the connectivity information that comes with the unstructured grid\n\nScalability especially for kilometer-scale (e.g. individual storm-resolving) resolutions is limited.\n\nMatplotlib can still serve as a visualization backend for unstriuctured grid visualization, especially for the end-user who is familiar with Matplotlib and would like to create publication-quality outputs.\n\nMoreover, just like conversion to Spatialpandas.GeoDataFrame, conversions to Matplotlib data structures such as Collections can be utilized for unstructrued grid plotting directly with the Matplotlib interface.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#matplotlib","position":21},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Collections","lvl2":"Matplotlib"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#collections","position":22},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Collections","lvl2":"Matplotlib"},"content":"Detailed information about Matplotlib’s Collections API can be found \n\nhere. Conversions to LineCollection and PolyCollection can help visualize Grid Geometries and data variables, respectively.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#collections","position":23},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Cartopy","lvl2":"Matplotlib"},"type":"lvl3","url":"/notebooks/foundations/plotting-libs#cartopy","position":24},{"hierarchy":{"lvl1":"Plotting Libraries","lvl3":"Cartopy","lvl2":"Matplotlib"},"content":"\n\nCartopy is originally a Python library for cartographic visualizations with Matplotlib; however, they provide a number of features such as crs, i.e. Coordinate Reference Systems (a.k.a. projections), that are significant for cartographic visualizations.\n\n","type":"content","url":"/notebooks/foundations/plotting-libs#cartopy","position":25},{"hierarchy":{"lvl1":"Plotting Libraries","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/foundations/plotting-libs#what-is-next","position":26},{"hierarchy":{"lvl1":"Plotting Libraries","lvl2":"What is next?"},"content":"The next section will provide an overview of the rendering techniques that can be used for visualizing unstructrued grids.","type":"content","url":"/notebooks/foundations/plotting-libs#what-is-next","position":27},{"hierarchy":{"lvl1":"Rendering Techniques"},"type":"lvl1","url":"/notebooks/foundations/rendering-techniques","position":0},{"hierarchy":{"lvl1":"Rendering Techniques"},"content":"","type":"content","url":"/notebooks/foundations/rendering-techniques","position":1},{"hierarchy":{"lvl1":"Rendering Techniques"},"type":"lvl1","url":"/notebooks/foundations/rendering-techniques#rendering-techniques","position":2},{"hierarchy":{"lvl1":"Rendering Techniques"},"content":"","type":"content","url":"/notebooks/foundations/rendering-techniques#rendering-techniques","position":3},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"In this section, you’ll learn:"},"type":"lvl3","url":"/notebooks/foundations/rendering-techniques#in-this-section-youll-learn","position":4},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"In this section, you’ll learn:"},"content":"Rendering methods that can be used for unstructured grids visualization.","type":"content","url":"/notebooks/foundations/rendering-techniques#in-this-section-youll-learn","position":5},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/foundations/rendering-techniques#related-documentation","position":6},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"Related Documentation"},"content":"No UXarray documentation is referenced here since this section covers the content from a general point of view.","type":"content","url":"/notebooks/foundations/rendering-techniques#related-documentation","position":7},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/foundations/rendering-techniques#prerequisites","position":8},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nGeometry\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\nSince Unstructured Grids require significantly more overhead to represent compared to Structured grids, the choice of rendering technique plays an important role in obtaining high-resolution, accurate, and scalable visualizations.\n\nThis notebook introduces relevant concepts and techniques that will be mentioned and used throughout this Cookbook.\n\n","type":"content","url":"/notebooks/foundations/rendering-techniques#prerequisites","position":9},{"hierarchy":{"lvl1":"Rendering Techniques","lvl2":"Vector (Shape) Geometries"},"type":"lvl2","url":"/notebooks/foundations/rendering-techniques#vector-shape-geometries","position":10},{"hierarchy":{"lvl1":"Rendering Techniques","lvl2":"Vector (Shape) Geometries"},"content":"The nodes (vertices), edges, and faces (cells) that make up an Unstructured Grid can each be converted into a geometric shape for visualization. These geometric shapes can often be referred to as vector graphics, since each geometry is mathematically represented when rendering.\n\nFor example, in the “Plotting with UXarray” chapter, we will showcase how we can convert the faces in our Unstructured Grid into Polygons.\n\nWhen constructing unstructured grids visualization, we can render each face directly onto the screen.\n\nRendering each face as a polygon will lead to visuals that look like this, which are high-quality since they represent the exact geometry of each face.\n\n \n\n \n\nAnother example of Vector Geometries is encountered when adding features to a visualization, such as Contents or Borders. The geometries of these features are drawn onto our screen.\n\n \n\n \n\n","type":"content","url":"/notebooks/foundations/rendering-techniques#vector-shape-geometries","position":11},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"Shapely Example","lvl2":"Vector (Shape) Geometries"},"type":"lvl3","url":"/notebooks/foundations/rendering-techniques#shapely-example","position":12},{"hierarchy":{"lvl1":"Rendering Techniques","lvl3":"Shapely Example","lvl2":"Vector (Shape) Geometries"},"content":"\n\nOne Python package which is used for representing and manipulating geometries is \n\nShapely.\n\nShapely can be paired with SpatialPandas and other packages to represent unstructured grid elements (nodes, edges, faces) as geometries for visualization.\n\nThe following code snippets are basic examples of how these elements can be represented as geometries.\n\nimport shapely as sp\n\nA node is represented as a pair of longitude and latitude coordinates\n\nsp.Point([0.0, 0.0])\n\nAn edge is represented as a pair of nodes.\n\nsp.LineString([[0.0, 0.0], [180, -90]])\n\nA face is represented as a counter-clockwise set of nodes, with the first and final nodes in the set being equivalent (form a closed face)\n\nsp.Polygon([[100, 40], [100, 50], [90, 50], [90, 40], [100, 40]])\n\n","type":"content","url":"/notebooks/foundations/rendering-techniques#shapely-example","position":13},{"hierarchy":{"lvl1":"Rendering Techniques","lvl2":"Rasterization"},"type":"lvl2","url":"/notebooks/foundations/rendering-techniques#rasterization","position":14},{"hierarchy":{"lvl1":"Rendering Techniques","lvl2":"Rasterization"},"content":"While there is definitely merit in rendering each geometric shape directly, this operation is computationally expensive for large datasets.\n\nRasterization is a technique in computer graphics that converts vector (a.k.a geometric shapes) graphics into a raster image, which can be thought of as a regularly-sampled array of pixel values used for rendering.\n\nThe figure below shows a simplified example of how rasterization “approximates” the geometry of different elements.\n\n \n\n \n\nFor unstructured grids, rasterization looks something like the following.\n\n \n\n \n\nThe black edges outline the expected geometry of each face (a.k.a polygon).\n\nWe can observe the jaggedness in the shading, which is the product of rasterization approximating each face.\n\nNote:The selection between vector graphics and rasterization needs to be made taking into account several factors such as how large is the dataset (i.e. how fine-resolution the data is), what data fidelity with the visualization is desired, what performance is expected, etc.\n\nSee also:A more comprehensive showcase of rasterization can be found \n\nhere\n\n","type":"content","url":"/notebooks/foundations/rendering-techniques#rasterization","position":15},{"hierarchy":{"lvl1":"Rendering Techniques","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/foundations/rendering-techniques#what-is-next","position":16},{"hierarchy":{"lvl1":"Rendering Techniques","lvl2":"What is next?"},"content":"Up next is the new chapter that will provide an Introduction to UXarray.","type":"content","url":"/notebooks/foundations/rendering-techniques#what-is-next","position":17},{"hierarchy":{"lvl1":"Unstructured Grids Overview"},"type":"lvl1","url":"/notebooks/foundations/unstructured-grids","position":0},{"hierarchy":{"lvl1":"Unstructured Grids Overview"},"content":"","type":"content","url":"/notebooks/foundations/unstructured-grids","position":1},{"hierarchy":{"lvl1":"Unstructured Grids Overview"},"type":"lvl1","url":"/notebooks/foundations/unstructured-grids#unstructured-grids-overview","position":2},{"hierarchy":{"lvl1":"Unstructured Grids Overview"},"content":"","type":"content","url":"/notebooks/foundations/unstructured-grids#unstructured-grids-overview","position":3},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"In this section, you’ll learn:"},"type":"lvl3","url":"/notebooks/foundations/unstructured-grids#in-this-section-youll-learn","position":4},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"In this section, you’ll learn:"},"content":"What unstructured meshes are and how they are different than structured grids\n\nGrid terminology and conventions\n\nUnstructured grid formats","type":"content","url":"/notebooks/foundations/unstructured-grids#in-this-section-youll-learn","position":5},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/foundations/unstructured-grids#related-documentation","position":6},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Related Documentation"},"content":"UXarray Terminology Documentation\n\nUXarray Conventions Documentation\n\nUXarray Supported Models and Grid Formats Documentation","type":"content","url":"/notebooks/foundations/unstructured-grids#related-documentation","position":7},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/foundations/unstructured-grids#prerequisites","position":8},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nCF Conventions\n\nNecessary\n\n\n\nUGRID Conventions\n\nHelpful\n\n\n\nNumpy\n\nHelpful\n\n\n\nXarray\n\nHelpful\n\n\n\nTime to learn: 15 minutes\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#prerequisites","position":9},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Structured vs Unstructured Grids"},"type":"lvl2","url":"/notebooks/foundations/unstructured-grids#structured-vs-unstructured-grids","position":10},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Structured vs Unstructured Grids"},"content":"\n\nBefore diving into unstructured grids, it is helpful to understand the basic differences between structured and unstructured grids:\n\nA structured grid is composed of grid cells (faces) that are well-organized in a predictable, grid-like topology, where simple indexing can be used to identify neighboring cells,\n\nAn unstructured grid represents the globe as a tesselation of various polygons (e.g. triangles, hexagons, etc.) to represent complex geometries, allowing those elements to be joined in any manner, but requiring explicit information to identify neighboring elements such as cells and nodes (vertices).\n\nNote that the focus here is on the horizontally unstructured grids in the climate and weather context, which may or may not involve vertical levels, but the same concepts apply to three dimensional unstructured grids as well.\n\nExamples of structured grids (on left) and unstructured grids (center and right) can be seen below:\n\n\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#structured-vs-unstructured-grids","position":11},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Structured Grids","lvl2":"Structured vs Unstructured Grids"},"type":"lvl3","url":"/notebooks/foundations/unstructured-grids#structured-grids","position":12},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Structured Grids","lvl2":"Structured vs Unstructured Grids"},"content":"\n\nA few advantages of structured grids are:\n\nUniform Representation: Simplifies numerical methods and enhances result interpretation.\n\nEfficient Numerics: Well-suited for finite-difference schemes, ensuring computational efficiency.\n\nSimplified Interpolation: Straightforward interpolation facilitates integration of observational data and model outputs.\n\nBoundary Handling: Ideal for regular boundaries, easing implementation of boundary conditions.\n\nOptimized Parallel Computing: Regular structure supports efficient parallel computing for scalability.\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#structured-grids","position":13},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl4":"Sample Xarray Code to Generate a Basic Structured Grid","lvl3":"Structured Grids","lvl2":"Structured vs Unstructured Grids"},"type":"lvl4","url":"/notebooks/foundations/unstructured-grids#sample-xarray-code-to-generate-a-basic-structured-grid","position":14},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl4":"Sample Xarray Code to Generate a Basic Structured Grid","lvl3":"Structured Grids","lvl2":"Structured vs Unstructured Grids"},"content":"\n\nThe code below shows the creation of a structured grid example over 2D Earth geometry and plots random temperature data over it. There are several ways and tools to create a structured grid, but this code works as follows:\n\nGiven the number of points in longitude and latitude directions, the code uses Numpy’s meshgrid to generate a structured grid. The temperature data is then interpolated onto this grid, creating a smooth representation. Xarray is leveraged to organize the gridded data into a dataset, facilitating easy manipulation and visualization. The resulting plot showcases the data on this structured grid, providing a clearer understanding of temperature variations across defined longitude and latitude ranges. Plotting the structured grid and the temperature data is done using Matplotlib along with Cartopy, a cartographic plotting library.\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\n\n# Define the global domain\nlat_range = [-90.0, 90.0]\nlon_range = [-180.0, 180.0]\n\n# Create a structured grid. Note the number of points in each dimension\n# There is not need to store the grid points in a separate array\n# Also note that the grid points are evenly spaced and not connectivity information is needed\n\nnum_lat_points = 20\nnum_lon_points = 30\n\nlats = np.linspace(lat_range[0], lat_range[1], num_lat_points)\nlons = np.linspace(lon_range[0], lon_range[1], num_lon_points)\n\nlons_grid, lats_grid = np.meshgrid(lons, lats)\n\n# Generate random temperature data for each grid point\ntemperature_data = np.random.uniform(\n    low=20, high=30, size=(num_lat_points, num_lon_points)\n)\n\n# Create xarray Dataset\nds = xr.Dataset()\nds[\"temperature\"] = ([\"lat\", \"lon\"], temperature_data)\nds[\"lon\"] = lons\nds[\"lat\"] = lats\n\n# Plot the structured grid using xarray\nfig, ax = plt.subplots(subplot_kw={\"projection\": ccrs.PlateCarree()})\nax.set_global()\n\n# Plot world map lines\nax.coastlines()\nax.gridlines(draw_labels=True, dms=True, x_inline=False, y_inline=False)\n\n# Plot the structured grid\ncs = ax.pcolormesh(\n    ds[\"lon\"], ds[\"lat\"], ds[\"temperature\"], cmap=\"coolwarm\", shading=\"auto\"\n)\n\n# Colorbar\ncbar = plt.colorbar(cs, ax=ax, label=\"Temperature (°C)\")\n\nax.set_title(\"Structured Grid Example\")\nplt.show()\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#sample-xarray-code-to-generate-a-basic-structured-grid","position":15},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Unstructured Grids","lvl2":"Structured vs Unstructured Grids"},"type":"lvl3","url":"/notebooks/foundations/unstructured-grids#unstructured-grids","position":16},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl3":"Unstructured Grids","lvl2":"Structured vs Unstructured Grids"},"content":"\n\nCharacteristic features of unstructured grids are:\n\nAdaptability to complex geometries: Fits intricate shapes and boundaries\n\nOften runs faster than structured grids: Requires fewer elements to achieve similar accuracy\n\nLocal refinement: Concentrates resolution on areas of interest\n\nFlexibility in element types: Accommodates various element shapes\n\nEfficient parallelization: Scales well to multiple processors\n\nSuitability for dynamic simulations: Adapts to changing conditions\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#unstructured-grids","position":17},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl4":"Sample Xarray Code to Generate a Basic Unstructured Mesh","lvl3":"Unstructured Grids","lvl2":"Structured vs Unstructured Grids"},"type":"lvl4","url":"/notebooks/foundations/unstructured-grids#sample-xarray-code-to-generate-a-basic-unstructured-mesh","position":18},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl4":"Sample Xarray Code to Generate a Basic Unstructured Mesh","lvl3":"Unstructured Grids","lvl2":"Structured vs Unstructured Grids"},"content":"\n\nThe code below uses a very basic, standard Python approach to showcase a simple unstructured mesh topology (without a real meaning or value).\n\nThis code generates an unstructured grid out of 600 arbitrarily created nodes (latitude, longitude pairs sampled from corresponding ranges via a uniform distribution). It performs Delaunay triangulation of those nodes using matplotlib.tri.Triangulation to create grid cells. The resulting triangulation is then plotted using cartopy and matplotlib.\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nimport numpy as np\nimport xarray as xr\n\n# Generate random temperature data\nnp.random.seed(42)\nnum_points = 600\nlatitudes = np.random.uniform(low=-90, high=90, size=num_points)\nlongitudes = np.random.uniform(low=-180, high=180, size=num_points)\ntemperatures = np.random.uniform(low=-30, high=30, size=num_points)\n\n# Create xarray DataArray for temperature data\ntemperature_data = xr.DataArray(\n    temperatures, dims=\"points\", coords={\"points\": range(num_points)}\n)\n\n# Perform Delaunay triangulation\ntriang = mtri.Triangulation(longitudes, latitudes)\n\n# Create xarray DataArray for triangulation coordinates\ntriang_data = xr.DataArray(\n    np.column_stack([triang.x, triang.y]), dims=(\"points\", \"coords\")\n)\n\n# Plot the globe with unstructured mesh using xarray\nfig, ax = plt.subplots(subplot_kw={\"projection\": ccrs.PlateCarree()})\nax.set_global()\n\n# Plot world map lines with prominent gridlines\nax.coastlines(linewidth=0.5)\n# ax.gridlines(draw_labels=True, dms=True, x_inline=False, y_inline=False, linewidth=0.5)\n\n# Plot unstructured mesh with bold lines\nax.triplot(\n    triang, \"ko-\", markersize=0.1, linewidth=0.5, alpha=0.5\n)  # Increase linewidth to see the triangles\n\n# Scatter plot with temperature data\nsc = ax.scatter(\n    longitudes,\n    latitudes,\n    c=temperature_data,\n    cmap=\"coolwarm\",\n    s=10,\n    transform=ccrs.PlateCarree(),\n)\n\n# Colorbar\ncbar = plt.colorbar(sc, ax=ax, label=\"Temperature (°C)\")\n\nax.set_title(\"Unstructured Mesh Example\")\nplt.show()\n\nNote:This is a very basic example to show how an unstructured grid with triangles would look like. In actual model outputs, often the region of interest is meshed with a finer resolution, while it is coarsened in areas where high resolution is not needed. This is done to reduce the number of elements and improve computational efficiency.\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#sample-xarray-code-to-generate-a-basic-unstructured-mesh","position":19},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Why Unstructured Grids?"},"type":"lvl2","url":"/notebooks/foundations/unstructured-grids#why-unstructured-grids","position":20},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Why Unstructured Grids?"},"content":"\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#why-unstructured-grids","position":21},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl4":"Arrival of the next generation, kilometer-scale global models for weather and climate","lvl2":"Why Unstructured Grids?"},"type":"lvl4","url":"/notebooks/foundations/unstructured-grids#arrival-of-the-next-generation-kilometer-scale-global-models-for-weather-and-climate","position":22},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl4":"Arrival of the next generation, kilometer-scale global models for weather and climate","lvl2":"Why Unstructured Grids?"},"content":"The aforementioned features and strengths of unstructured grids make them appealing for data analysis and visualization of kilometer-scale global weather and climate model outputs that produce very large spatio-temporal datasets.\n\nTherefore, after nearly two decades of development and evaluation, the climate and global weather modeling communities are transitioning from simple structured grids to this kind of more complex, but more scalable unstructured grids upon which governing equations of state are solved.\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#arrival-of-the-next-generation-kilometer-scale-global-models-for-weather-and-climate","position":23},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Many Unstructured Grid Types, No Commonly Used Convention or Tools"},"type":"lvl2","url":"/notebooks/foundations/unstructured-grids#many-unstructured-grid-types-no-commonly-used-convention-or-tools","position":24},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Many Unstructured Grid Types, No Commonly Used Convention or Tools"},"content":"\n\nThere are several climate and weather models that generate unstructured grids that vary from each other regarding not only the geometric elements (shape of grid faces, i.e. polygons, etc.) but also the file formats and extensions, and how special information such as geometric elements’ connectivity is represented. This creates a challenge towards having a widely used convention for the representation of unstructured grid data.\n\nThere are only a few analysis tools that are capable of working directly with unstructured mesh data that come from so many mesh formats, and most of the time, the common practice is to resample to structured grids, but this has myriad pitfalls.\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#many-unstructured-grid-types-no-commonly-used-convention-or-tools","position":25},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Why UXarray for Unstructured Grids?"},"type":"lvl2","url":"/notebooks/foundations/unstructured-grids#why-uxarray-for-unstructured-grids","position":26},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"Why UXarray for Unstructured Grids?"},"content":"UXarray, which stands for “Unstructured Grids - Xarray”, is a Python package that provides Xarray-styled analysis and visualization functionality for working directly with unstructured grids that are resulting from most of the climate and weather models. Offering a unified representation of various model outputs around the UGRID conventions, UXarray enables working with native unstructured grids in a single, grid format-agnostic interface.\n\nMore on UXarray in the next chapter.\n\n","type":"content","url":"/notebooks/foundations/unstructured-grids#why-uxarray-for-unstructured-grids","position":27},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/foundations/unstructured-grids#what-is-next","position":28},{"hierarchy":{"lvl1":"Unstructured Grids Overview","lvl2":"What is next?"},"content":"The next section will provide an overview of the general-purpose plotting libraries available in the scientific Python ecosystem.","type":"content","url":"/notebooks/foundations/unstructured-grids#what-is-next","position":29},{"hierarchy":{"lvl1":"UXarray Grid"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/grid","position":0},{"hierarchy":{"lvl1":"UXarray Grid"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/grid","position":1},{"hierarchy":{"lvl1":"UXarray Grid"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/grid#uxarray-grid","position":2},{"hierarchy":{"lvl1":"UXarray Grid"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/grid#uxarray-grid","position":3},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"In this tutorial, you’ll learn:"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/grid#in-this-tutorial-youll-learn","position":4},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"In this tutorial, you’ll learn:"},"content":"What is a UXarray Grid?\n\nHow to load a Grid\n\nHow to access Grid attributes","type":"content","url":"/notebooks/intro-to-uxarray/grid#in-this-tutorial-youll-learn","position":5},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/grid#related-documentation","position":6},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Related Documentation"},"content":"UXarray Data Structures Documentation","type":"content","url":"/notebooks/intro-to-uxarray/grid#related-documentation","position":7},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/grid#prerequisites","position":8},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nUnstructured Grids\n\nNecessary\n\n\n\nPython programming\n\nNecessary\n\n\n\nIntroduction to Xarray\n\nHelpful\n\n\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#prerequisites","position":9},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#overview","position":10},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Overview"},"content":"\n\nIn the previous section, we briefly introduced the Grid class, which stores unstructured grid variables such as coordinates and connectivity. This class is the foundation of UXarray, which ensures awareness of the unstructured grid topology between operations. Exploring the grid geometry can be helpful throughout analysis and visualization workflows.\n\nNote:In most cases, checking the ``Grid`` object of either ``UxDataset`` or ``UxDataArray`` is anticipated be the common scenario since majority of the UXarray workflows will rely on a data set and its variable(s) of interest. Such cases will be showcased as part of many of the following notebooks; thus, this tutorial will focus on the latter where we explore a standalone ``Grid`` object.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#overview","position":11},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Unstructured Grid Files"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#unstructured-grid-files","position":12},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Unstructured Grid Files"},"content":"\n\nIn the following sections, we will look into loading a standalone grid-specific file. The coordinates and connectivity variables of an unstructured grid are often stored as a separate unstructured grid file.\n\ngrid_path = \"../../meshfiles/outCSne30.grid.ug\"\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#unstructured-grid-files","position":13},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Loading a Grid"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#loading-a-grid","position":14},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Loading a Grid"},"content":"\n\nThe suggested way to construct a standalone Grid is by using the uxarray.open_grid() method. When constructing a standalone grid, only topology variables such as coordinates and connectivity are used to construct the grid. This means that any data variables that reside on the unstructured grid, such as temperature, would not be stored in a Grid. Pairing the grid definiton with data variables will be covered in the next notebook.\n\nimport uxarray as ux\n\nuxgrid = ux.open_grid(grid_path)\nuxgrid\n\nPrinting a Grid displays the contents of our newly created grid object. If you are coming from an Xarray background, this output will look very similar to what one might see when constructing an xarray.Dataset.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#loading-a-grid","position":15},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Coordinates"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#coordinates","position":16},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Coordinates"},"content":"\n\nDifferent types of coordinates for the geometric elements of a Grid are either constructed upfront during the  grid instantiation or generated at the time of use.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#coordinates","position":17},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Spherical Coordinates","lvl2":"Coordinates"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/grid#spherical-coordinates","position":18},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Spherical Coordinates","lvl2":"Coordinates"},"content":"\n\nThe spherical node coordinates are always instantiated upfront with the grid initialization and can be examined through the grid attributes such as node_lon, node_lat, etc:\n\nuxgrid.node_lon\n\nHowever, the spherical face and edge coordinates might not be readily available in the grid definition (see the  original Grid object above for reference) and would need to be generated by UXarray when prompted; for instance:\n\nuxgrid.face_lon\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#spherical-coordinates","position":19},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Cartesian coordinates","lvl2":"Coordinates"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/grid#cartesian-coordinates","position":20},{"hierarchy":{"lvl1":"UXarray Grid","lvl3":"Cartesian coordinates","lvl2":"Coordinates"},"content":"\n\nThe original uxgrid object above shows no Cartesian coordinates; however, UXarray is able to generate those as soon as the user tries to access one of them; for instance:\n\nuxgrid.node_x\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#cartesian-coordinates","position":21},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Connectivity"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#connectivity","position":22},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Connectivity"},"content":"\n\nIn unstructured grid geometry, connectivity information between each type of geometric elements can be defined, e.g. face-node, node-edge, edge-face, etc. UXarray requires only the face-node connectivity, either coming from the grid definition or being constructed by UXarray in special cases, in addition to the node coordinates to represent the topology.\n\nUXarray can also generate all the other connectivity information when prompted.\n\nLet us look at the face-node connectivity, for example:\n\nuxgrid.face_node_connectivity\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#connectivity","position":23},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Descriptors"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#descriptors","position":24},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"Descriptors"},"content":"\n\nUXarray provides descriptors for further information about the geometry. For instance, an array that shows the number of nodes for each face can be helpful to determine if the grid is uniformly constructed of a single shape or multiple n-gons, and simplify some of the grid-specific calculations as well.\n\nuxgrid.n_nodes_per_face\n\n","type":"content","url":"/notebooks/intro-to-uxarray/grid#descriptors","position":25},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/grid#what-is-next","position":26},{"hierarchy":{"lvl1":"UXarray Grid","lvl2":"What is next?"},"content":"The next section will cover the other core data structures of UXarray, UxDataset and UxDataArray classes and how to open unstructured grid datasets for data analysis and visualization purposes.","type":"content","url":"/notebooks/intro-to-uxarray/grid#what-is-next","position":27},{"hierarchy":{"lvl1":"Overview"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/overview","position":0},{"hierarchy":{"lvl1":"Overview"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/overview","position":1},{"hierarchy":{"lvl1":"Overview"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/overview#overview","position":2},{"hierarchy":{"lvl1":"Overview"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/overview#overview","position":3},{"hierarchy":{"lvl1":"Overview","lvl3":"In this section, you’ll learn:"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/overview#in-this-section-youll-learn","position":4},{"hierarchy":{"lvl1":"Overview","lvl3":"In this section, you’ll learn:"},"content":"What is UXarray?\n\nWhy UXarray?\n\nHow UXarray is designed\n\nUXarray Core API to work with unstructured grids","type":"content","url":"/notebooks/intro-to-uxarray/overview#in-this-section-youll-learn","position":5},{"hierarchy":{"lvl1":"Overview","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/overview#related-documentation","position":6},{"hierarchy":{"lvl1":"Overview","lvl3":"Related Documentation"},"content":"UXarray Homepage\n\nUXarray “Why UXarray?” Documentation\n\nUXarray Data Structures Documentation\n\nUXarray Supported Models & Grid Formats Documentation","type":"content","url":"/notebooks/intro-to-uxarray/overview#related-documentation","position":7},{"hierarchy":{"lvl1":"Overview","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/overview#prerequisites","position":8},{"hierarchy":{"lvl1":"Overview","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nXarray\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/intro-to-uxarray/overview#prerequisites","position":9},{"hierarchy":{"lvl1":"Overview","lvl2":"What is UXarray?"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/overview#what-is-uxarray","position":10},{"hierarchy":{"lvl1":"Overview","lvl2":"What is UXarray?"},"content":"\n\nThe “U” in UXarray stands for “Unstructured Grids”. UXarray extends upon and inherits from \n\nXarray for providing the Earth system sciences community with analysis and visualization functionality that can operate directly on the native unstructured mesh data resulting from climate and global weather models and observations.\n\nUXarray is written around the \n\nUGRID conventions to represent several different unstructured mesh types in an unified, \n\nClimate and Forecast metadata convention (CF)-compliant format.\n\nSpecifically, UXarray’s core functionality supports horizontally unstructured grids with vertical levels as defined by the 2D Flexible Mesh Topology in the UGRID conventions, which can contain a mix of triangles, quadrilaterals, or other geometric faces.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/overview#what-is-uxarray","position":11},{"hierarchy":{"lvl1":"Overview","lvl2":"Why UXarray?"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/overview#why-uxarray","position":12},{"hierarchy":{"lvl1":"Overview","lvl2":"Why UXarray?"},"content":"\n\nUXarray can simplify working with unstructured grids because it:\n\nEnables significant data analysis and visualization functionality to be executed directly on unstructured grids\n\nAdheres to the UGRID specifications for compatibility across a variety of mesh formats\n\nProvides a single interface for supporting a variety of unstructured grid formats including UGRID, MPAS, SCRIP, and Exodus (See the full list of \n\nUXarray’s supported models and grid formats)\n\nInherits from Xarray, providing simplified data using familiar (Xarray-like) data structures and operations\n\nBrings standardization to unstructured mesh support for climate data analysis and visualization\n\nBuilds on optimized data structures and algorithms for handling large and complex unstructured datasets\n\nSupports enhanced interoperability and community collaboration\n\n","type":"content","url":"/notebooks/intro-to-uxarray/overview#why-uxarray","position":13},{"hierarchy":{"lvl1":"Overview","lvl2":"UXarray Design"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/overview#uxarray-design","position":14},{"hierarchy":{"lvl1":"Overview","lvl2":"UXarray Design"},"content":"\n\nUXarray is designed around three core data structures, Grid, UxDataset, and UxDataArray:\n\nGrid provides unstructured grid awareness for the data analysis and visualization functionality implemented through UxDataset and UxDataArray. It houses grid-specific methods and topology variables.\n\nUxDataset inherits from the xarray.Dataset class, providing much of the same functionality but extended to operate on Unstructured Grids through new and overloaded methods. Each UxDataset is linked to its own Grid object through the use of a class property (UxDataset.uxgrid) to provide a grid-aware implementation. An instance of UxDataset can be thought of as a collection of data variables, i.e. UxDataArray objects, that reside on a particular Unstructured Grid as defined in the uxgrid property.\n\nUxDataArray similarly inherits from the xarray.DataArray class, providing single data variable-level functionality to operate on Unstructured Grids through new and overloaded methods. Similar to UxDataset, it has a link to its own Grid object (UxDataArray.uxgrid). For isntance, if several UxDataArray variables exist in an UxDataset object, each of them will have a link to the same Grid object that proves all of them reside on the same unstructured grid topology.\n\nNote:The following notebooks will detail each of these data structures; hence, we are keeping it short here in this section.\n\nGiven the introductions to the core UXarray data structures, let us have a look at the UXarray design diagram below:\n\n\n\n","type":"content","url":"/notebooks/intro-to-uxarray/overview#uxarray-design","position":15},{"hierarchy":{"lvl1":"Overview","lvl2":"UXarray’s Core API and Unstructured Grids"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/overview#uxarrays-core-api-and-unstructured-grids","position":16},{"hierarchy":{"lvl1":"Overview","lvl2":"UXarray’s Core API and Unstructured Grids"},"content":"\n\nWhen working with unstructured grids, the grid topology definition is typically stored in a dedicated grid file, separately from any data file(s), i.e. the whole dataset contains a single grid definition file along with one or more data files. However, in other less common cases, the grid definition might be embedded into the data file(s).\n\nUXarray is able to handle both of these cases thanks to the core API for opening grid and data files (or other storage objects). The following notebooks in this chapter will cover the core API for these cases.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/overview#uxarrays-core-api-and-unstructured-grids","position":17},{"hierarchy":{"lvl1":"Overview","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/overview#what-is-next","position":18},{"hierarchy":{"lvl1":"Overview","lvl2":"What is next?"},"content":"The next section will provide an introduction to the UXarray’s Grid class and how to open standalone grid files.","type":"content","url":"/notebooks/intro-to-uxarray/overview#what-is-next","position":19},{"hierarchy":{"lvl1":"Spatial Selection Operators"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/selection","position":0},{"hierarchy":{"lvl1":"Spatial Selection Operators"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/selection","position":1},{"hierarchy":{"lvl1":"Spatial Selection Operators"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/selection#spatial-selection-operators","position":2},{"hierarchy":{"lvl1":"Spatial Selection Operators"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/selection#spatial-selection-operators","position":3},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"In this tutorial, you’ll learn:"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#in-this-tutorial-youll-learn","position":4},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"In this tutorial, you’ll learn:"},"content":"Using UXarray to select specific regions from an unstructured grid","type":"content","url":"/notebooks/intro-to-uxarray/selection#in-this-tutorial-youll-learn","position":5},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#related-documentation","position":6},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Related Documentation"},"content":"UXarray Subsetting Documentation\n\nUXarray Cross-Section Documentation","type":"content","url":"/notebooks/intro-to-uxarray/selection#related-documentation","position":7},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#prerequisites","position":8},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nUXDataset & UxDataArray Notebook\n\nNecessary\n\n\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#prerequisites","position":9},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/selection#overview","position":10},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"Overview"},"content":"When working with unstructured grids, a region or zone rather than the entire global grid might be of interest for data analysis and visualization. Such spatial selection of the grid/data might help with not only analyzing/plotting a specific region/zone, but also reducing the data size and increasing the performance as well as allowing the entire plots to be effectively displayed on the screen.\n\nThis notebook showcases how to spatially subset a grid and take a cross-section of the grid at a constant latitude and longitude.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#overview","position":11},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"Subsetting"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/selection#subsetting","position":12},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"Subsetting"},"content":"UXarray provides functionality for subsetting the grid into a bounding box, bounding circle, or K-nearest neighbors.\n\nBefore demonstrating them, let us load some global data first:\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#subsetting","position":13},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Load Data","lvl2":"Subsetting"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#load-data","position":14},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Load Data","lvl2":"Subsetting"},"content":"\n\n# Import\nimport cartopy.crs as ccrs\nimport geoviews.feature as gf\nimport uxarray as ux\n\ngrid_path = \"../../meshfiles/x1.655362.grid.nc\"\ndata_path = \"../../meshfiles/x1.655362.data.nc\"\n\n# Open dataset and grab a data variable of interest\nuxds = ux.open_dataset(grid_path, data_path)\nuxda = uxds[\"relhum_200hPa\"][0]\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#load-data","position":15},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Global Data","lvl2":"Subsetting"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#plot-the-global-data","position":16},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Global Data","lvl2":"Subsetting"},"content":"\n\nNote!The visualizations throughout this tutorial are only for demonstrating the results of the subsetting and cross-sections versus the global grid. Since the details of plotting with UXarray will be covered in the next chapter, we will not go over any details of the plots here.\n\nplot_opts = {\"width\": 700, \"height\": 350}\n\nfeatures = gf.coastline(\n    projection=ccrs.PlateCarree(), line_width=0.4, scale=\"50m\"\n) * gf.states(projection=ccrs.PlateCarree(), line_width=0.4, scale=\"50m\")\n\nclim = (uxda.values.min(), uxda.values.max())\n\nuxda.plot(\n    rasterize=True, periodic_elements=\"exclude\", title=\"Global Grid\", **plot_opts\n) * features\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#plot-the-global-data","position":17},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Generate Various Subsets","lvl2":"Subsetting"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#generate-various-subsets","position":18},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Generate Various Subsets","lvl2":"Subsetting"},"content":"\n\n# Bounding box around Boulder, CO\nref_lon = -105.2705\nref_lat = 40.0150\nref_offset = 1\n\nlon_bounds = (ref_lon - ref_offset, ref_lon + ref_offset)\nlat_bounds = (ref_lat - ref_offset, ref_lat + ref_offset)\n\n# Subset the global data variable and its grid using the bounding box\nuxda_bbox = uxda.subset.bounding_box(lon_bounds, lat_bounds)\n\n\n\n# Now use a bounding circle subsetting\nref_center = [ref_lon, ref_lat]\n\nuxda_bcircle = uxda.subset.bounding_circle(ref_center, ref_offset)\n\n# Now use a K-nearest neighbor subsetting\nk_nn = 60\n\nuxda_nn = uxda.subset.nearest_neighbor(ref_center, k=k_nn, element=\"nodes\")\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#generate-various-subsets","position":19},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Subsets","lvl2":"Subsetting"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#plot-the-subsets","position":20},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Subsets","lvl2":"Subsetting"},"content":"\n\nplot_bbox = (\n    uxda_bbox.plot(\n        rasterize=True,\n        periodic_elements=\"exclude\",\n        clim=clim,\n        title=\"Bounding Box Subset around Boulder, CO (Corner Node Query)\",\n        **plot_opts,\n    )\n    * features\n)\n\nplot_bcircle = (\n    uxda_bcircle.plot(\n        rasterize=True,\n        periodic_elements=\"exclude\",\n        clim=clim,\n        title=\"Bounding Circle Subset around Boulder, CO (Corner Node Query)\",\n        **plot_opts,\n    )\n    * features\n)\n\nplot_nn = (\n    uxda_nn.plot(\n        rasterize=True,\n        periodic_elements=\"exclude\",\n        clim=clim,\n        title=\"K-Nearest Neighbor Subset around Boulder, CO (Corner Node Query)\",\n        **plot_opts,\n    )\n    * features\n)\n\n(plot_bbox + plot_bcircle + plot_nn).cols(1)\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#plot-the-subsets","position":21},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"Cross-sections"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/selection#cross-sections","position":22},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"Cross-sections"},"content":"Similarly, UXarray provides functionality for taking cross-sections of a grid/data at constant latitudes and longitudes.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#cross-sections","position":23},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Load Data","lvl2":"Cross-sections"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#load-data-1","position":24},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Load Data","lvl2":"Cross-sections"},"content":"\n\n# Data paths\ngrid_path = \"../../meshfiles/outCSne30.grid.ug\"\ndata_path = \"../../meshfiles/outCSne30.data.nc\"\n\n# Open dataset and grab a data variable of interest\nuxds = ux.open_dataset(grid_path, data_path)\nuxda = uxds[\"psi\"]\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#load-data-1","position":25},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Global Data","lvl2":"Cross-sections"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#plot-the-global-data-1","position":26},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Global Data","lvl2":"Cross-sections"},"content":"\n\nprojection = ccrs.Robinson()\n\nfeatures_2 = gf.coastline(\n    projection=projection, line_width=0.4, scale=\"50m\"\n) * gf.states(projection=projection, line_width=0.4, scale=\"50m\")\n\nuxda.plot(\n    cmap=\"inferno\",\n    periodic_elements=\"split\",\n    projection=projection,\n    title=\"Global Plot\",\n) * features_2\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#plot-the-global-data-1","position":27},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Generate Cross-Sections","lvl2":"Cross-sections"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#generate-cross-sections","position":28},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Generate Cross-Sections","lvl2":"Cross-sections"},"content":"\n\n# Cross-section at the latitude of Boulder, CO\ncross_lat = 40.0150\n\nuxda_cross_lat = uxda.cross_section.constant_latitude(cross_lat)\n\n# Now cross-section at the longitude of Boulder, CO\ncross_lon = -105.2705\n\nuxda_cross_lon = uxda.cross_section.constant_longitude(cross_lon)\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#generate-cross-sections","position":29},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Cross-Sections","lvl2":"Cross-sections"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/selection#plot-the-cross-sections","position":30},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl3":"Plot The Cross-Sections","lvl2":"Cross-sections"},"content":"\n\nplot_cross_lat = (\n    uxda_cross_lat.plot(\n        rasterize=False,\n        backend=\"bokeh\",\n        cmap=\"inferno\",\n        projection=projection,\n        global_extent=True,\n        coastline=True,\n        title=f\"Cross-section at ({cross_lat}) degrees latitude around Boulder, CO\",\n    )\n    * features_2\n)\n\nplot_cross_lon = (\n    uxda_cross_lon.plot(\n        rasterize=False,\n        backend=\"bokeh\",\n        cmap=\"inferno\",\n        projection=projection,\n        global_extent=True,\n        coastline=True,\n        title=f\"Cross-section at ({cross_lon}) degrees longitude around Boulder, CO\",\n    )\n    * features_2\n)\n\n(plot_cross_lat + plot_cross_lon).cols(1)\n\n","type":"content","url":"/notebooks/intro-to-uxarray/selection#plot-the-cross-sections","position":31},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/selection#what-is-next","position":32},{"hierarchy":{"lvl1":"Spatial Selection Operators","lvl2":"What is next?"},"content":"With this section, we have wrapped up this chapter, move on to the next chapter!","type":"content","url":"/notebooks/intro-to-uxarray/selection#what-is-next","position":33},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/uxds-uxda","position":0},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda","position":1},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray"},"type":"lvl1","url":"/notebooks/intro-to-uxarray/uxds-uxda#uxarray-dataset-dataarray","position":2},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray"},"content":"","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#uxarray-dataset-dataarray","position":3},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"In this section, you’ll learn:"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/uxds-uxda#in-this-section-youll-learn","position":4},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"In this section, you’ll learn:"},"content":"What are UxDataset and UxDataArray?\n\nHow do they relate to their Xarray counterparts?","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#in-this-section-youll-learn","position":5},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Related Documentation"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#related-documentation","position":6},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Related Documentation"},"content":"UXarray Data Structures Documentation","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#related-documentation","position":7},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"Prerequisites","lvl2":"Related Documentation"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/uxds-uxda#prerequisites","position":8},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"Prerequisites","lvl2":"Related Documentation"},"content":"Concepts\n\nImportance\n\nNotes\n\nIntroduction to Xarray\n\nNecessary\n\n\n\nTime to learn: 15 minutes\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#prerequisites","position":9},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#overview","position":10},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Overview"},"content":"\n\nAs stated before in this chapter, UxDataset and UxDataArray are the UXarray classes that are inherited from Xarray counterparts and enable to perform analysis and visualization on unstructured mesh datasets.\n\nAn instance of UxDataset can be thought of as a collection of data variables, i.e. UxDataArray objects, that reside on a particular unstructured grid as defined in the class property (UxDataset.uxgrid or UxDataArray.uxgrid).\n\nIn other words, each of these data structures is linked to its own Grid object through uxgrid to enable grid-awareness, and for UxDataArrays that belong to a specific UxDataset, uxgrid of all of them points to the same Grid object.\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#overview","position":11},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Unstructured Mesh Datasets"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#unstructured-mesh-datasets","position":12},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Unstructured Mesh Datasets"},"content":"\n\nSince most of the unstructured grid datasets contain a single grid definition file along with one or more data files, UXarray’s core API allows to open such datasets using those files.\n\nLet the following dataset have a single data file along with the grid definition:\n\ngrid_path = \"../../meshfiles/outCSne30.grid.ug\"\ndata_path = \"../../meshfiles/outCSne30.data.nc\"\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#unstructured-mesh-datasets","position":13},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Loading a UxDataset"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#loading-a-uxdataset","position":14},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Loading a UxDataset"},"content":"\n\nTo open a grid file with a single data file, the uxarray.open_dataset() method can be used. UXarray also provides uxarray.open_mfdataset() for opening multiple data files at once (refer to the \n\nUXarray Opening Multipled Data Files Documentation for that), but this notebook will cover only the former.\n\nimport uxarray as ux\n\nuxds = ux.open_dataset(grid_path, data_path)\nuxds\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#loading-a-uxdataset","position":15},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"Grid Accessor","lvl2":"Loading a UxDataset"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/uxds-uxda#grid-accessor","position":16},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"Grid Accessor","lvl2":"Loading a UxDataset"},"content":"Let us first see the Gridobject this dataset object is linked to:\n\nuxds.uxgrid\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#grid-accessor","position":17},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Accessing Data Variables (UxDataArray)"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#accessing-data-variables-uxdataarray","position":18},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Accessing Data Variables (UxDataArray)"},"content":"Similar to the Xarray conterparts, an UxDataset can have multiple UxDataArrays in it, which are for different data variables. A variable of interest can be accessed in the same way Xarray provides:\n\nuxds[\"psi\"]\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#accessing-data-variables-uxdataarray","position":19},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"Grid Accessor","lvl2":"Accessing Data Variables (UxDataArray)"},"type":"lvl3","url":"/notebooks/intro-to-uxarray/uxds-uxda#grid-accessor-1","position":20},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl3":"Grid Accessor","lvl2":"Accessing Data Variables (UxDataArray)"},"content":"The Gridobject of this data array is the same Grid object as uxds’s above:\n\nuxda = uxds[\"psi\"]\nuxda.uxgrid\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#grid-accessor-1","position":21},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Relationship to Xarray"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#relationship-to-xarray","position":22},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"Relationship to Xarray"},"content":"\n\nFor users coming from an Xarray background, much of UXarray’s design is familiar thanks to the UXarray’s inheritance of the core data structures from Xarray’s counterparts and employment of design choices such as accessors. Inheritance has been chosen for the UXarray design both to provide the users with a Xarray-like user experience and to use the built-in Xarray functionality whenever possible while overwrite the others for unstructured grid arithmetic.\n\nAs a simple Xarray example that would replicate the above UXarray dataset opening and variable access with UXarray, please see the following code:\n\n# Import\nimport xarray as xr\n\n# Structured grid data file\ndata_path_structured = \"../../meshfiles/outCSne30.structured.nc\"\n\n# Open dataset with Xarray\nxrds = xr.open_dataset(data_path_structured)\nxrds\n\nxrda = xrds[\"psi\"]\nxrda\n\nSee also:For further information, please visit the \n\nUXarray Inheritance from Xarray documentation\n\n","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#relationship-to-xarray","position":23},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"What is next?"},"type":"lvl2","url":"/notebooks/intro-to-uxarray/uxds-uxda#what-is-next","position":24},{"hierarchy":{"lvl1":"UXarray Dataset & DataArray","lvl2":"What is next?"},"content":"The next section is the final section in this chapter that will provide information about how to operate spatial selection methods on UxDataArray.","type":"content","url":"/notebooks/intro-to-uxarray/uxds-uxda#what-is-next","position":25},{"hierarchy":{"lvl1":"Comparison to Xarray"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/compare-xarray","position":0},{"hierarchy":{"lvl1":"Comparison to Xarray"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray","position":1},{"hierarchy":{"lvl1":"Comparison to Xarray"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/compare-xarray#comparison-to-xarray","position":2},{"hierarchy":{"lvl1":"Comparison to Xarray"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#comparison-to-xarray","position":3},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"In this tutorial, you’ll learn about:"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#in-this-tutorial-youll-learn-about","position":4},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"In this tutorial, you’ll learn about:"},"content":"The differences and similarities between UXarray’s and Xarray’s plotting routines\n\nUsing hvPlot with Xarray","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#in-this-tutorial-youll-learn-about","position":5},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#related-documentation","position":6},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Related Documentation"},"content":"UXarray Plotting User Guide","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#related-documentation","position":7},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#prerequisites","position":8},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nXarray\n\nNecessary\n\n\n\nTime to learn: 5 minutes\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#prerequisites","position":9},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Introduction"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/compare-xarray#introduction","position":10},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Introduction"},"content":"For users coming from an Xarray background, much of UXarray’s design is familiar. This notebook showcases an example of transitioning a visualization of a structured grid using Xarray into a visualization of an unstructured grid using UXarray.\n\nimport cartopy.crs as ccrs\nimport matplotlib.pyplot as plt\nimport uxarray as ux\nimport xarray as xr\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#introduction","position":11},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Data"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/compare-xarray#data","position":12},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Data"},"content":"We use two variations of the outCSne30 grid for this example. One of them is the original unstructured cube sphere, with the other being a remapped structured version.","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#data","position":13},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Xarray","lvl2":"Data"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#xarray","position":14},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Xarray","lvl2":"Data"},"content":"\n\nbase_path = \"../../meshfiles/\"\nds_path = base_path + \"outCSne30.structured.nc\"\nxrds = xr.open_dataset(ds_path)\nxrds\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#xarray","position":15},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"UXarray","lvl2":"Data"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#uxarray","position":16},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"UXarray","lvl2":"Data"},"content":"\n\nbase_path = \"../../meshfiles/\"\ngrid_filename = base_path + \"outCSne30.grid.ug\"\ndata_filename = base_path + \"outCSne30.data.nc\"\n\nuxds = ux.open_dataset(grid_filename, data_filename)\nuxds\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#uxarray","position":17},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Visualization"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/compare-xarray#visualization","position":18},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Visualization"},"content":"\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#visualization","position":19},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Xarray","lvl2":"Visualization"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#xarray-1","position":20},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"Xarray","lvl2":"Visualization"},"content":"\n\nxrds[\"psi\"].plot(figsize=(12, 5), cmap=\"inferno\")\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#xarray-1","position":21},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"UXarray","lvl2":"Visualization"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/compare-xarray#uxarray-1","position":22},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl3":"UXarray","lvl2":"Visualization"},"content":"\n\nuxds[\"psi\"].plot(width=800, height=400, backend=\"matplotlib\", cmap=\"inferno\")\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#uxarray-1","position":23},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Using hvPlot to combine UXarray & Xarray Plots"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/compare-xarray#using-hvplot-to-combine-uxarray-xarray-plots","position":24},{"hierarchy":{"lvl1":"Comparison to Xarray","lvl2":"Using hvPlot to combine UXarray & Xarray Plots"},"content":"Since UXarray is written using hvPlot, we can visualize Xarray and UXarray plots together by using hvplot.xarray.\n\nSee also:To learn more about hvPlot and Xarray, please refer to the \n\nhvPlot Documentation\n\nimport holoviews as hv\nimport hvplot.xarray\n\nhv.extension(\"bokeh\")\n\n(\n    xrds.hvplot(cmap=\"inferno\", title=\"Xarray with hvPlot\", width=800, height=400)\n    + uxds[\"psi\"].plot(\n        cmap=\"inferno\",\n        title=\"UXarray Plot\",\n        width=800,\n        height=400,\n        periodic_elements=\"split\",\n    )\n).cols(1)","type":"content","url":"/notebooks/plotting-with-uxarray/compare-xarray#using-hvplot-to-combine-uxarray-xarray-plots","position":25},{"hierarchy":{"lvl1":"Customization & Interactivity"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/customization","position":0},{"hierarchy":{"lvl1":"Customization & Interactivity"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/customization","position":1},{"hierarchy":{"lvl1":"Customization & Interactivity"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/customization#customization-interactivity","position":2},{"hierarchy":{"lvl1":"Customization & Interactivity"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/customization#customization-interactivity","position":3},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl3":"In this tutorial, you’ll learn about:"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/customization#in-this-tutorial-youll-learn-about","position":4},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl3":"In this tutorial, you’ll learn about:"},"content":"Switching between Bokeh and Matplotlib backends for different rendering capabilities\n\nSetting up default plot parameters to maintain consistent styling across visualizations\n\nUsing dynamic rasterization\n\nLeveraging Bokeh’s interactive features for data exploration, including zooming, panning, and hover tools","type":"content","url":"/notebooks/plotting-with-uxarray/customization#in-this-tutorial-youll-learn-about","position":5},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl3":"Related Documentation"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/customization#related-documentation","position":6},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl3":"Related Documentation"},"content":"Plotting with Bokeh\n\nPlotting with Matplotlib\n\nCustomization\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/customization#related-documentation","position":7},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Introduction"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/customization#introduction","position":8},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Introduction"},"content":"An essential feature of UXarray is its seamless integration with hvPlot, a powerful plotting library that provides extensive customization and interactivity capabilities. This integration means that when you create visualizations using UXarray, you have access to most of hvPlot’s features for tailoring your plots and making them interactive.\n\nimport cartopy.crs as ccrs\nimport holoviews as hv\nimport uxarray as ux\nfrom IPython.display import Image\n\ngrid_path = \"../../meshfiles/oQU480.grid.nc\"\ndata_path = \"../../meshfiles/oQU480.data.nc\"\n\nuxds = ux.open_dataset(grid_path, data_path)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/customization#introduction","position":9},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Plot Parameters"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/customization#plot-parameters","position":10},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Plot Parameters"},"content":"For a comprehensive understanding of the available customization options, please refer to the \n\nhvPlot Customization Guide.\n\nRather than duplicating the extensive documentation available in hvPlot’s user guide, we encourage you to familiarize yourself with their customization options directly. This will provide you with the complete range of parameters available for tailoring your visualizations to meet your specific requirements.\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/customization#plot-parameters","position":11},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Selecting a Renderer"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/customization#selecting-a-renderer","position":12},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Selecting a Renderer"},"content":"One key advantage is the flexibility to choose your preferred plotting backend. While Bokeh serves as the default renderer, you can easily switch to Matplotlib by specifying the backend parameter in your plotting commands. This allows you to leverage the unique strengths of each renderer – Bokeh’s interactive features or Matplotlib’s publication-quality static plots.\n\nhv.extension(\"bokeh\")\nuxds[\"bottomDepth\"].plot()\n\n# can also do the following\n# uxds[\"bottomDepth\"].plot(backend='bokeh')\n\nhv.extension(\"matplotlib\")\nuxds[\"bottomDepth\"].plot()\n\n# can also do the following\n# uxds[\"bottomDepth\"].plot(backend='matplotlib')\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/customization#selecting-a-renderer","position":13},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Setting Default Parameters"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/customization#setting-default-parameters","position":14},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Setting Default Parameters"},"content":"When creating multiple visualizations, you may want to maintain consistent styling across your plots. HoloViews provides a convenient way to set default parameters through hv.opts.defaults, eliminating the need to repeatedly specify the same parameters for each plot.\n\nIn the example below,we set default parameters for all Polygon plots using hv.opts.defaults(hv.opts.Polygons()). The specified parameters: width of 600 pixels, height of 300 pixels, and a default title, will automatically apply to any subsequent Polygon plots unless explicitly overridden.\n\nThis approach is particularly useful when developing consistent visualizations for reports or presentations. Rather than manually setting dimensions and styling for each plot, you can establish these parameters once at the beginning of your notebook. This not only saves time but also ensures visual consistency throughout your analysis.\n\nDefault parameters can be updated at any point in your notebook, giving you the flexibility to modify the styling of subsequent plots while maintaining the efficiency of centralized parameter management.\n\nhv.extension(\"bokeh\")\nhv.opts.defaults(hv.opts.Polygons(width=600, title=\"My Default Title\", height=300))\n\nuxds[\"bottomDepth\"].plot()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/customization#setting-default-parameters","position":15},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Dynamic Rendering"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/customization#dynamic-rendering","position":16},{"hierarchy":{"lvl1":"Customization & Interactivity","lvl2":"Dynamic Rendering"},"content":"UXarray leverages hvPlot’s dynamic rasterization feature through the dynamic=True parameter. This capability automatically adjusts the plot’s resolution based on your current view, ensuring optimal performance without sacrificing data fidelity.\n\nAs you zoom into specific regions of your plot, the visualization engine recalculates and re-rasterizes the data for your current viewport. This means you’ll see increasing levels of detail as you examine smaller areas, revealing fine structures that might not be visible in the full-scale view. This adaptive approach maintains interactive performance while providing high-resolution details where they matter most.\n\nFor example, when examining a global ocean mesh, you might start with a view of the entire grid. Upon zooming into a coastal region, the dynamic rasterization automatically refines the visualization, showing intricate mesh elements and local features that were previously aggregated in the broader view. This functionality is particularly valuable when working with multi-resolution meshes or datasets with varying spatial density.\n\nSince the rendered notebooks do not perform the re-rasterization, two GIFs have been provided with commented out code blocks. If you are working on this notebook locally, you can uncomment the code and explore the behavior interactively.\n\nhv.extension(\"bokeh\")\n\n# uxds['bottomDepth'].plot()\n\n\n\n# uxds['bottomDepth'].plot(dynamic=True)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/customization#dynamic-rendering","position":17},{"hierarchy":{"lvl1":"Data Visualization"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/data-viz","position":0},{"hierarchy":{"lvl1":"Data Visualization"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz","position":1},{"hierarchy":{"lvl1":"Data Visualization"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/data-viz#data-visualization","position":2},{"hierarchy":{"lvl1":"Data Visualization"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#data-visualization","position":3},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"In this tutorial, you’ll learn about:"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#in-this-tutorial-youll-learn-about","position":4},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"In this tutorial, you’ll learn about:"},"content":"Working with data variables on unstructured grid elements including nodes, edges, and faces\n\nPolygon plotting techniques (vector & raster)\n\nPoint plotting techniques (vector & raster)\n\nHandling periodic elements for 2D visualization\n\nTime to learn: 15 minutes\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#in-this-tutorial-youll-learn-about","position":5},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Introduction"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/data-viz#introduction","position":6},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Introduction"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#introduction","position":7},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Building on Grid Visualization","lvl2":"Introduction"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#building-on-grid-visualization","position":8},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Building on Grid Visualization","lvl2":"Introduction"},"content":"Our exploration of unstructured grid visualization continues from the \n\nprevious section, where we examined geometric visualization using the Grid class. We now advance to the next critical aspect: visualizing data variables mapped to unstructured grid elements.","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#building-on-grid-visualization","position":9},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Understanding Data Element Mapping","lvl2":"Introduction"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#understanding-data-element-mapping","position":10},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Understanding Data Element Mapping","lvl2":"Introduction"},"content":"The visualization approach for unstructured grid data depends fundamentally on how data variables map to specific grid elements. Each variable may correspond to nodes, edges, or faces, and this mapping determines the most effective visualization strategy. This relationship between data and grid elements forms the foundation for selecting appropriate visualization techniques that accurately represent your data’s spatial distribution and relationships.\n\nimport uxarray as ux\n\ngrid_path = \"../../meshfiles/oQU480.grid.nc\"\ndata_path = \"../../meshfiles/oQU480.data.nc\"\n\nuxds = ux.open_dataset(grid_path, data_path)\nuxds[\"bottomDepth\"]\n\nOur data variable above, bottomDepth, has a final dimension of n_face, meaning that it is mapped to the faces of our grid.\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#understanding-data-element-mapping","position":11},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Plotting Accessor"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/data-viz#plotting-accessor","position":12},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Plotting Accessor"},"content":"UXarray provides streamlined access to all visualization methods through the UxDataArray.plot accessor. This interface serves as the central entry point for data visualization, with each data array supporting a default visualization method when calling UxDataArray.plot().\n\nuxds[\"bottomDepth\"].plot()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#plotting-accessor","position":13},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Polygons"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/data-viz#polygons","position":14},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Polygons"},"content":"Face-centered data variables are visualized by default using raster polygon plots. In these plots, each face within the unstructured grid is represented as a distinct polygon. The polygons are shaded according to their corresponding data values.\n\nuxds[\"bottomDepth\"].plot.polygons()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#polygons","position":15},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Raster vs Vector Polygons","lvl2":"Polygons"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#raster-vs-vector-polygons","position":16},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Raster vs Vector Polygons","lvl2":"Polygons"},"content":"By default, polygon rasterization is enabled (rasterize=True). This setting optimizes performance by converting vector polygons into a raster format when rendering. For high-resolution grids, maintaining rasterization is strongly recommended, as rendering individual vector polygons can significantly impact performance.\n\nDisabling rasterization (rasterize=False) switches to direct vector polygon rendering, which may be suitable for simpler visualizations where maintaining vector properties is essential.\n\nuxds[\"bottomDepth\"].plot.polygons(rasterize=False)\n\nVector polygon plots maintain complete data fidelity regardless of zoom level, preserving both accuracy and visual quality throughout any magnification. This characteristic distinguishes them from rasterized alternatives, which may show pixelation upon close inspection.\n\nThe following visualization demonstrates this advantage. When examining a magnified region of our grid, the vector-rendered polygons maintain their crisp definition and precise data representation.\n\n(\n    uxds[\"bottomDepth\"].plot.polygons(\n        rasterize=False, xlim=(-20, 0), ylim=(-5, 5), title=\"Vector Polygons\"\n    )\n    + uxds[\"bottomDepth\"].plot.polygons(\n        rasterize=True, xlim=(-20, 0), ylim=(-5, 5), title=\"Raster Polygons\"\n    )\n).cols(1)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#raster-vs-vector-polygons","position":17},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Handling Periodic Elements","lvl2":"Polygons"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#handling-periodic-elements","position":18},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Handling Periodic Elements","lvl2":"Polygons"},"content":"Visualizing unstructured grids on a spherical surface presents unique challenges, particularly when dealing with the antimeridian (180° longitude). This longitudinal line, where the Eastern and Western hemispheres meet, requires special consideration to ensure accurate 2D visualization of data that crosses this boundary.\n\nUXarray addresses this challenge through its periodic_elements parameter in polygon plotting functions. This parameter offers three approaches for managing faces that intersect with the antimeridian:\n\nperiodic_elements='exclude' (Default)\nFaces that cross the antimeridian are masked, removing them from the visualization. While this approach may omit some data, it offers optimal performance and is recommended for most use cases.\n\nperiodic_elements='split'\nFaces that cross the antimeridian are divided, ensuring complete data representation. However, this processing step impacts the initial plotting time.\n\nperiodic_elements='ignore'\nFaces that cross the antimeridian are not processed.\n\nFor optimal visualization performance, we recommend maintaining the default periodic_elements='exclude' setting unless complete data representation at the antimeridian is essential for your specific analysis.\n\n(\n    uxds[\"bottomDepth\"].plot.polygons(\n        periodic_elements=\"exclude\", title=\"periodic_elements='exclude'\"\n    )\n    + uxds[\"bottomDepth\"].plot.polygons(\n        periodic_elements=\"split\", title=\"periodic_elements='split'\"\n    )\n).cols(1)\n\nWhen working with data near or across the antimeridian (180° longitude), selecting an appropriate projection becomes crucial for accurate visualization. For comprehensive guidance on handling such scenarios, including recommended projections and geographic features, please refer to the \n\nGeographic Projections & Features notebook.\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#handling-periodic-elements","position":19},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Polygon Plots for Node/Edge Data","lvl2":"Polygons"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#polygon-plots-for-node-edge-data","position":20},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Polygon Plots for Node/Edge Data","lvl2":"Polygons"},"content":"Polygon plots require face-centered data variables, as each polygon must be rendered with a single value. This limitation presents a challenge when working with node-centered or edge-centered data, requiring a conversion process to map the data to faces.\n\nOne effective approach is to perform topological averaging. This method calculates the mean value of adjacent nodes or edges and assigns the result to each face, creating a face-centered representation suitable for polygon visualization. While this transformation may introduce some averaging effects, it provides a practical solution for visualizing node and edge data within the constraints of polygon plotting.\n\ngrid_path = \"../../meshfiles/hex.grid.nc\"\ndata_path = \"../../meshfiles/hex.node.data.nc\"\n\nuxds_node_centered = ux.open_dataset(grid_path, data_path)\n\nuxds_node_centered[\"random_data_node\"].topological_mean(destination=\"face\").plot()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#polygon-plots-for-node-edge-data","position":21},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Points"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/data-viz#points","position":22},{"hierarchy":{"lvl1":"Data Visualization","lvl2":"Points"},"content":"Points provide an alternative visualization method that offers flexibility across different data mappings. This approach maps data values to specific coordinates, enabling visualization of node-centered, edge-centered, or face-centered data.\n\nThe following visualization demonstrates this technique using face-centered data. Each point corresponds to a face center coordinate and displays its associated data value. This method maintains data fidelity while presenting the information in a discrete, coordinate-based format.\n\nuxds[\"bottomDepth\"].plot.points()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#points","position":23},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Rasterization","lvl2":"Points"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/data-viz#rasterization","position":24},{"hierarchy":{"lvl1":"Data Visualization","lvl3":"Rasterization","lvl2":"Points"},"content":"As with polygon-based visualizations, point-based plots support rasterization through the rasterize=True parameter. This optimization technique converts vector-based points into a raster format during rendering.\n\nuxds[\"bottomDepth\"].plot.points(rasterize=True)\n\nPoint-based rasterization demonstrates different characteristics across varying data resolutions. For coarse-resolution data like our example, point-based visualization produces notably lower visual quality compared to polygon-based approaches.\n\nHowever, rasterized point plots emerge as a valuable tool for high-resolution grid visualization, offering significant performance advantages. For detailed information about leveraging this technique with high-resolution data, please refer to the \n\nVisualizing High-Resolution Grids section.","type":"content","url":"/notebooks/plotting-with-uxarray/data-viz#rasterization","position":25},{"hierarchy":{"lvl1":"Geographic Projections & Features"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/geo","position":0},{"hierarchy":{"lvl1":"Geographic Projections & Features"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/geo","position":1},{"hierarchy":{"lvl1":"Geographic Projections & Features"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/geo#geographic-projections-features","position":2},{"hierarchy":{"lvl1":"Geographic Projections & Features"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/geo#geographic-projections-features","position":3},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl3":"In this tutorial, you’ll learn about:"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/geo#in-this-tutorial-youll-learn-about","position":4},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl3":"In this tutorial, you’ll learn about:"},"content":"Selecting appropriate projections for your specific visualization needs\n\nAdding geographic features to provide context for your data\n\nCustomizing projection parameters to optimize your visualizations\n\nRelated Documentation\n\nhvPlot Geographic Options","type":"content","url":"/notebooks/plotting-with-uxarray/geo#in-this-tutorial-youll-learn-about","position":5},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl3":"Prerequisites"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/geo#prerequisites","position":6},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl3":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nCartopy\n\nNecessary\n\n\n\nGeoViews\n\nHelpfull\n\n\n\nTime to learn: 5 minutes","type":"content","url":"/notebooks/plotting-with-uxarray/geo#prerequisites","position":7},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl2":"Introduction"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/geo#introduction","position":8},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl2":"Introduction"},"content":"When visualizing geospatial data on unstructured grids, choosing the right map projection is crucial for accurately representing your data. Geographic projections transform the three-dimensional surface of the Earth onto a two-dimensional plane, each offering different trade-offs between preserving area, distance, direction, or shape.\n\nUXarray leverages Cartopy’s robust projection capabilities to provide flexible geographic visualization options. Through integration with hvPlot and GeoViews, UXarray allows you to easily switch between different projections and add geographic features like coastlines and borders to enhance your visualizations.\n\nWe’ll use practical examples to demonstrate these capabilities, focusing on common use cases in climate science, oceanography, and other geophysical applications where unstructured grids are prevalent.\n\nimport cartopy.crs as ccrs\nimport uxarray as ux\n\ngrid_path = \"../../meshfiles/oQU480.grid.nc\"\ndata_path = \"../../meshfiles/oQU480.data.nc\"\n\nuxds = ux.open_dataset(grid_path, data_path)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/geo#introduction","position":9},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl2":"Projections"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/geo#projections","position":10},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl2":"Projections"},"content":"The geographic projection used for visualization can be specified through the projection parameter in UXarray’s plotting methods. UXarray utilizes Cartopy’s Coordinate Reference System (CRS) objects to define these projections.\n\nThe simplest way to set a projection is to create a Cartopy CRS object and pass it to the plotting method.\n\nprojection = ccrs.Orthographic()\nprojection\n\nuxds[\"bottomDepth\"].plot.polygons(projection=projection)\n\nWhen visualizing data concentrated in specific geographic regions, adjusting the projection’s center point can significantly improve the visualization’s clarity and accuracy. Many projections, including the Orthographic projection, provide central_longitude and central_latitude parameters for this purpose.\n\nThis capability is particularly valuable when working with data near the antimeridian (180°/ longitude). For instance, data centered around the Pacific Ocean often crosses this boundary, which can cause visualization artifacts or split features across the edges of the plot. By setting central_longitude=180, you can shift the projection’s center to properly display these regions:\n\nprojection = ccrs.Orthographic(central_longitude=-180)\nprojection\n\nuxds[\"bottomDepth\"].plot.polygons(projection=projection)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/geo#projections","position":11},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl2":"Features"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/geo#features","position":12},{"hierarchy":{"lvl1":"Geographic Projections & Features","lvl2":"Features"},"content":"Geographic features are specified through the features parameter in your plotting command. You can add multiple features by providing them as a list.\n\nAvailable features include ‘borders’, ‘coastline’, ‘lakes’, ‘land’, ‘ocean’, ‘rivers’ and ‘states’.\n\nuxds[\"bottomDepth\"].plot.polygons(\n    projection=projection, features=[\"borders\", \"coastline\"]\n)\n\nThe resolution of geographic features can be controlled by specifying a scale in the features parameter. This is done by passing a dictionary that maps each feature to its desired scale. There are three resolution levels: ‘10m’ (highest detail), ‘50m’ (medium detail), and ‘110m’ (lowest detail).\n\nuxds[\"bottomDepth\"].plot.polygons(\n    projection=projection, features={\"borders\": \"10m\", \"coastline\": \"10m\"}\n)","type":"content","url":"/notebooks/plotting-with-uxarray/geo#features","position":13},{"hierarchy":{"lvl1":"Grid Visualization"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/grid-viz","position":0},{"hierarchy":{"lvl1":"Grid Visualization"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz","position":1},{"hierarchy":{"lvl1":"Grid Visualization"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/grid-viz#grid-visualization","position":2},{"hierarchy":{"lvl1":"Grid Visualization"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#grid-visualization","position":3},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"In this section, you’ll learn about:"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/grid-viz#in-this-section-youll-learn-about","position":4},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"In this section, you’ll learn about:"},"content":"Plotting the edges of an unstructured grid\n\nPlotting the coordinates of an unstructured grid\n\nRelated Documentation\n\nUXarray Plotting User Guide\n\nTime to learn: 10 minutes\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#in-this-section-youll-learn-about","position":5},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Introduction"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/grid-viz#introduction","position":6},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Introduction"},"content":"Unstructured grids play a vital role in scientific computing and numerical simulations. UXarray’s Grid data structure provides a robust foundation for working with these grids by managing essential variables like coordinates and connectivity information. Before conducting complex data analysis or running simulations, it’s often crucial to visualize and verify the grid geometry.\n\nThis visualization capability serves multiple purposes: It helps users understand the mesh topology, identify potential issues in grid generation, and verify boundary conditions. For example, when preparing to run a dynamical core simulation, scientists often examine the computational grid to ensure it meets their requirements for spatial resolution and element quality.\n\nTo demonstrate these visualization techniques, we’ll work with a straightforward example: An unstructured grid consisting of four hexagonal elements.\n\nimport uxarray as ux\n\ngrid_path = \"../../meshfiles/hex.grid.nc\"\n\nuxgrid = ux.open_grid(grid_path)\nuxgrid\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#introduction","position":7},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Plotting Accessor"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/grid-viz#plotting-accessor","position":8},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Plotting Accessor"},"content":"UXarray provides streamlined access to all visualization methods through the Grid.plot accessor. This interface serves as the central entry point for grid visualization, with each grid object supporting a default visualization method when calling Grid.plot().\n\nuxgrid.plot(title=\"Default Plot Function\")\n\nAccessing specific plotting functions is showcased below.\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#plotting-accessor","position":9},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Visualizing Edges"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/grid-viz#visualizing-edges","position":10},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Visualizing Edges"},"content":"Edge visualization is a fundamental technique for understanding the unstructured grid topology. By plotting the edges between grid elements, we can examine the mesh structure, verify connectivity patterns, and assess the overall grid quality. The edge representation provides an intuitive view of how elements are arranged and connected.\n\nuxgrid.plot.edges(title=\"Edge Plot\")\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#visualizing-edges","position":11},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Visualizing Coordinates"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/grid-viz#visualizing-coordinates","position":12},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":"Visualizing Coordinates"},"content":"Unstructured grids incorporate three distinct types of geometric coordinates, each serving a specific purpose in defining the grid’s spatial structure and properties.","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#visualizing-coordinates","position":13},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Corner Nodes","lvl2":"Visualizing Coordinates"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/grid-viz#corner-nodes","position":14},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Corner Nodes","lvl2":"Visualizing Coordinates"},"content":"Corner nodes define the fundamental geometry of each grid element through their latitude and longitude coordinates, which are stored in the Grid.node_lat and Grid.node_lon variables.\n\nuxgrid.plot.corner_nodes(title=\"Corner Nodes\") * uxgrid.plot()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#corner-nodes","position":15},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Face Centers","lvl2":"Visualizing Coordinates"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/grid-viz#face-centers","position":16},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Face Centers","lvl2":"Visualizing Coordinates"},"content":"Face centers represent the geometric centroid of each grid element, with their latitude and longitude coordinates stored in the Grid.face_lat and Grid.face_lon variables.\n\nuxgrid.plot.face_centers(title=\"Face Centers\") * uxgrid.plot()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#face-centers","position":17},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Edge Centers","lvl2":"Visualizing Coordinates"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/grid-viz#edge-centers","position":18},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Edge Centers","lvl2":"Visualizing Coordinates"},"content":"Edge centers denote the midpoint of each grid boundary segment, with their spatial coordinates stored in the Grid.edge_lat and Grid.edge_lon variables.\n\nuxgrid.plot.edge_centers(title=\"Face Centers\") * uxgrid.plot()\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#edge-centers","position":19},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Plotting Everything Together","lvl2":"Visualizing Coordinates"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/grid-viz#plotting-everything-together","position":20},{"hierarchy":{"lvl1":"Grid Visualization","lvl3":"Plotting Everything Together","lvl2":"Visualizing Coordinates"},"content":"By combining the visualization of edges, face centers, corner nodes, and edge centers, we can generate a comprehensive representation of the unstructured grid’s geometry. This allows us to example the complete spatial structure of our grid.\n\n(\n    uxgrid.plot.edges(color=\"black\")\n    * uxgrid.plot.nodes(marker=\"o\", size=150).relabel(\"Corner Nodes\")\n    * uxgrid.plot.face_centers(marker=\"s\", size=150).relabel(\"Face Centers\")\n    * uxgrid.plot.edge_centers(marker=\"^\", size=150).relabel(\"Edge Centers\")\n).opts(title=\"Grid Coordinates\", legend_position=\"top_right\")\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz#plotting-everything-together","position":21},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":""},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/grid-viz","position":22},{"hierarchy":{"lvl1":"Grid Visualization","lvl2":""},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/grid-viz","position":23},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids"},"type":"lvl1","url":"/notebooks/plotting-with-uxarray/high-res","position":0},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids"},"content":"","type":"content","url":"/notebooks/plotting-with-uxarray/high-res","position":1},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"In this tutorial, you’ll learn about:"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/high-res#in-this-tutorial-youll-learn-about","position":2},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"In this tutorial, you’ll learn about:"},"content":"Techniques for visualizing high-resolution grids, including best practices for performance optimization and rendering\n\nThe importance of rasterization in managing computational overhead when working with detailed global datasets\n\nStrategic use of subsetting functionality to enhance visualization performance for regional analyses\n\nKey differences between point-based and polygon-based visualization approaches at varying grid resolutions\n\nEffective use of map projections to improve spatial data representation and address point distribution challenges\n\nControl and optimization of visualization quality through pixel ratio parameters for both point and polygon plots\n\nTime to learn: 15 minutes\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#in-this-tutorial-youll-learn-about","position":3},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl2":"Introduction"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/high-res#introduction","position":4},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl2":"Introduction"},"content":"This notebook explores techniques for working with high-resolution unstructured grids, building upon the foundational concepts previously covered. While earlier examples focused on coarse-resolution grids to introduce core principles, many real-world applications require handling more detailed grid structures.\n\nFor this demonstration, we utilize output from the 30km MPAS Atmosphere model, representing a significant increase in resolution compared to our previous examples. While this resolution allows us to effectively illustrate key visualization concepts, it’s important to note that atmospheric and climate models often employ even higher resolutions. The concepts covered in this notebook are applicable to these higher resolutions.\n\nimport cartopy.crs as ccrs\nimport holoviews as hv\nimport uxarray as ux\n\nhv.extension(\"matplotlib\")\n\ngrid_path = \"../../meshfiles/x1.655362.grid.nc\"\ndata_path = \"../../meshfiles/x1.655362.data.nc\"\n\nuxds = ux.open_dataset(grid_path, data_path)\nuxds[\"relhum_200hPa\"]\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#introduction","position":5},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl2":"Polygon Plots"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/high-res#polygon-plots","position":6},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl2":"Polygon Plots"},"content":"When working with high-resolution grids at global scales, performance optimization becomes crucial. As detailed in the \n\nData Visualization notebook, setting rasterize=True is strongly recommended for these scenarios. This parameter significantly improves rendering performance by converting vector-based polygons into raster images during visualization.\n\n%%time\nuxds[\"relhum_200hPa\"][0].plot.polygons(rasterize=True)\n\nThe initial rendering of polygon plots requires significant processing time due to the conversion of each grid face into a Polygon object and its subsequent storage in a GeoDataFrame. However, this computational investment yields long-term benefits: once these geometries are processed and stored, they can be efficiently reused in subsequent visualizations. This caching mechanism ensures that follow-up polygon plots render substantially faster, making the initial processing time a worthwhile trade-off for improved ongoing performance. Below we can observe the faster rendering time after the initial execution.\n\n%%time\nres = uxds[\"relhum_200hPa\"][0].plot.polygons(rasterize=True)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#polygon-plots","position":7},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Subsetting","lvl2":"Polygon Plots"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/high-res#subsetting","position":8},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Subsetting","lvl2":"Polygon Plots"},"content":"\n\nTo enhance performance when visualizing specific geographic regions, you can combine polygon plotting with subsetting functionality. This optimization strategy significantly reduces computational overhead by rendering only the polygons within your region of interest, rather than processing the entire grid. For example, when analyzing weather patterns over North America, subsetting the global grid to that continent will dramatically improve rendering speed and resource efficiency.\n\nrelhum_subset = uxds[\"relhum_200hPa\"][0].subset.bounding_box(\n    lon_bounds=[-5, 5], lat_bounds=[-2.5, 2.5]\n)\nrelhum_subset.plot.polygons(rasterize=True)\n\nWe can restrict our region even further to clearly see the original polygons.\n\nrelhum_subset = uxds[\"relhum_200hPa\"][0].subset.bounding_box(\n    lon_bounds=[-1.0, 1.0], lat_bounds=[-0.5, 0.5]\n)\nrelhum_subset.plot.polygons(rasterize=True)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#subsetting","position":9},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Controlling Resolution","lvl2":"Polygon Plots"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/high-res#controlling-resolution","position":10},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Controlling Resolution","lvl2":"Polygon Plots"},"content":"The pixel_ratio parameter offers precise control over resolution in polygon plots. This parameter determines how closely the rasterized output approximates the original vector-based polygon representation.\n\nSetting a larger pixel ratio produces higher-fidelity visualizations that more accurately represent the underlying data structure and polygon geometries. These high-resolution outputs closely resemble traditional vector polygon plots, preserving intricate spatial relationships and boundaries.\n\nConversely, specifying a smaller pixel ratio generates lower-resolution visualizations. While this approach may sacrifice some visual detail, it can significantly improve rendering performance for large datasets or when exact polygon boundaries are less critical for the analysis at hand.\n\nThis resolution control mechanism enables you to balance visual accuracy with computational efficiency based on your specific visualization requirements and performance constraints.\n\n(\n    uxds[\"relhum_200hPa\"][0].plot.polygons(\n        rasterize=True, pixel_ratio=0.1, title=\"0.1 Pixel Ratio\"\n    )\n    + uxds[\"relhum_200hPa\"][0].plot.polygons(\n        rasterize=True, pixel_ratio=4.0, title=\"4.0 Pixel Ratio\"\n    )\n).cols(1)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#controlling-resolution","position":11},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl2":"Point-Based Visualization Strategies"},"type":"lvl2","url":"/notebooks/plotting-with-uxarray/high-res#point-based-visualization-strategies","position":12},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl2":"Point-Based Visualization Strategies"},"content":"Previous examination of rasterized point plots in the \n\nData Visualization section revealed their limitations for coarse-resolution grids. However, as grid resolution increases, this visualization method becomes increasingly advantageous, delivering superior rendering performance compared to polygon-based approaches while maintaining high visual quality.\n\nOur 30km global grid demonstration showcases this enhanced effectiveness. At this resolution, rasterized point plots achieve visual fidelity approaching that of traditional polygon plots, though with two important technical considerations to address during implementation:\n\nThe visualization output exhibits missing values, denoted as NaN in the resulting display. Additionally, unprojected visualizations reveal an inherent characteristic of global coordinate systems: point density increases notably near the equator relative to the poles. This creates a distinctive variation in visual density—an expected artifact when representing spherical data in a planar format.\n\n%%time\nuxds[\"relhum_200hPa\"][0].plot.points(rasterize=True)\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#point-based-visualization-strategies","position":13},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Optimizing Point Distribution Using Map Projections","lvl2":"Point-Based Visualization Strategies"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/high-res#optimizing-point-distribution-using-map-projections","position":14},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Optimizing Point Distribution Using Map Projections","lvl2":"Point-Based Visualization Strategies"},"content":"Using appropriate map projections significantly enhances point distribution  offering marked improvements over unprojected representations. Map projections help normalize the spatial distribution of data points, substantially reducing the clustering effects observed in standard latitude-longitude visualizations.\n\nFor example, an Orthographic projection provides one effective approach, though various other projections can also help. While projections address many distribution challenges, some missing values may persist in the output. However, these remaining gaps typically represent a considerable improvement over unprojected versions, where equatorial clustering creates more pronounced visualization artifacts.\n\n%%time\nuxds[\"relhum_200hPa\"][0].plot.points(rasterize=True, projection=ccrs.Orthographic())\n\n","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#optimizing-point-distribution-using-map-projections","position":15},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Controlling Resolution & Binning","lvl2":"Point-Based Visualization Strategies"},"type":"lvl3","url":"/notebooks/plotting-with-uxarray/high-res#controlling-resolution-binning","position":16},{"hierarchy":{"lvl1":"Visualizing High-Resolution Grids","lvl3":"Controlling Resolution & Binning","lvl2":"Point-Based Visualization Strategies"},"content":"The pixel_ratio parameter provides precise control over the rasterization process by determining the size of individual raster pixels in your visualization. This parameter directly influences both the visual resolution and the data aggregation characteristics of your plot.\n\nWhen you specify a larger pixel ratio, the visualization creates smaller raster pixels. This higher-resolution approach means fewer data points are aggregated within each pixel, potentially leading to gaps in the visualization where pixels contain no data points. These empty pixels appear as NaN values in the final output.\n\nConversely, setting a smaller pixel ratio creates larger pixels that capture and aggregate more data points. This approach typically produces a more continuous visualization by reducing the likelihood of empty pixels, though it may sacrifice some fine detail in the process.\n\nThe pixel ratio effectively serves as a resolution control mechanism, allowing you to balance between granular detail and visual continuity based on your specific visualization requirements. This flexibility becomes particularly valuable when working with datasets of varying densities or when focusing on specific geographic regions that require different levels of detail.\n\n(\n    uxds[\"relhum_200hPa\"][0].plot.points(\n        rasterize=True,\n        projection=ccrs.Orthographic(),\n        pixel_ratio=0.5,\n        title=\"0.5 Pixel Ratio\",\n    )\n    + uxds[\"relhum_200hPa\"][0].plot.points(\n        rasterize=True,\n        projection=ccrs.Orthographic(),\n        pixel_ratio=3.0,\n        title=\"3.0 Pixel Ratio\",\n    )\n).cols(1)","type":"content","url":"/notebooks/plotting-with-uxarray/high-res#controlling-resolution-binning","position":17},{"hierarchy":{"lvl1":"E3SM Atmosphere"},"type":"lvl1","url":"/notebooks/recipes/e3sm","position":0},{"hierarchy":{"lvl1":"E3SM Atmosphere"},"content":"","type":"content","url":"/notebooks/recipes/e3sm","position":1},{"hierarchy":{"lvl1":"E3SM Atmosphere"},"type":"lvl1","url":"/notebooks/recipes/e3sm#e3sm-atmosphere","position":2},{"hierarchy":{"lvl1":"E3SM Atmosphere"},"content":"This recipe demonstrates how to analyze unstructured grid output from the Energy Exascale Earth System Model (E3SM) using UXarray. Unlike traditional approaches that require regridding, UXarray enables direct analysis of the native model output, preserving the full fidelity of the simulation data.","type":"content","url":"/notebooks/recipes/e3sm#e3sm-atmosphere","position":3},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Objectives"},"type":"lvl2","url":"/notebooks/recipes/e3sm#objectives","position":4},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Objectives"},"content":"This recipe guides you through calculating and visualizing key atmospheric radiation metrics:\n\nShortwave Cloud Radiative Effect (SWCRE)\n\nLongwave Cloud Radiative Effect (LWCRE)\n\nNet Cloud Radiative Effect (NetCRE)\n\nThe workflow includes techniques for:\n\nComputing radiation components directly on the native unstructured grid\n\nVisualizing spatial patterns between two time steps\n\nAnalyzing temporal evolution through difference plots\n\nimport cartopy.crs as ccrs\nimport holoviews as hv\nimport uxarray as ux\n\nhv.extension(\"bokeh\")\n\n","type":"content","url":"/notebooks/recipes/e3sm#objectives","position":5},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Data"},"type":"lvl2","url":"/notebooks/recipes/e3sm#data","position":6},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Data"},"content":"The example uses output from an E3SMv2 atmosphere-only (AMIP) simulation with the following specifications:\n\nSimulation Period: 6 years\n\nConfiguration: Present-day control forcing (F2010)\n\nResolution: 1-degree horizontal (ne30pg2)\n\nBoundary Conditions: Default E3SMv2 settings for sea surface temperatures and sea ice, cycling annually\n\ngrid_path = \"../../meshfiles/ne30pg2.grid.nc\"\ndata_path = \"../../meshfiles/ne30pg2.data.nc\"\n\nuxds = ux.open_dataset(grid_path, data_path)\n\n","type":"content","url":"/notebooks/recipes/e3sm#data","position":7},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Calculating Shortwave Cloud Radiative Effect (SWCRE)"},"type":"lvl2","url":"/notebooks/recipes/e3sm#calculating-shortwave-cloud-radiative-effect-swcre","position":8},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Calculating Shortwave Cloud Radiative Effect (SWCRE)"},"content":"Shortwave cloud radiative effect can be approximated as the difference beteween all-sky net shortwave flux (FSNT) at the top of the model and the clear-sky net shortwave flux (FSNTC).SWCRE = FSNT - FSNTC\n\nuxds[\"SWCRE\"] = uxds[\"FSNT\"] - uxds[\"FSNTC\"]\nuxds[\"SWCRE\"]\n\n","type":"content","url":"/notebooks/recipes/e3sm#calculating-shortwave-cloud-radiative-effect-swcre","position":9},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Calculating Longwave Cloud Radiative Effect (LWCRE)"},"type":"lvl2","url":"/notebooks/recipes/e3sm#calculating-longwave-cloud-radiative-effect-lwcre","position":10},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Calculating Longwave Cloud Radiative Effect (LWCRE)"},"content":"Longwave cloud radiative effect is similar to that for SWCRE, but the all-sky and clear-sky longwave fluxes are applied instead.LWCRE = FLUT - FLUTC\n\nuxds[\"LWCRE\"] = uxds[\"FLUT\"] - uxds[\"FLUTC\"]\nuxds[\"LWCRE\"]\n\n","type":"content","url":"/notebooks/recipes/e3sm#calculating-longwave-cloud-radiative-effect-lwcre","position":11},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Calculating Net Cloud Radiative Effect (NetCRE)"},"type":"lvl2","url":"/notebooks/recipes/e3sm#calculating-net-cloud-radiative-effect-netcre","position":12},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Calculating Net Cloud Radiative Effect (NetCRE)"},"content":"Net cloud radiative effect is thus the difference beteween shortwave and longwave cloud radiative effect.netCRE = SWCRE - LWCRE\n\nuxds[\"netCRE\"] = uxds[\"SWCRE\"] - uxds[\"LWCRE\"]\nuxds[\"netCRE\"]\n\n","type":"content","url":"/notebooks/recipes/e3sm#calculating-net-cloud-radiative-effect-netcre","position":13},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Plotting"},"type":"lvl2","url":"/notebooks/recipes/e3sm#plotting","position":14},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl2":"Plotting"},"content":"Having computed the Net Cloud Radiative Effect (NetCRE), we can now create visualizations to examine the spatial patterns and temporal evolution of cloud-radiation interactions. Our visualization approach focuses on three key aspects:\n\nInitial conditions represented by the first timestep\n\nFinal conditions from the last timestep\n\nThe difference between these states to reveal temporal changes\n\nThe following sections demonstrate how to create these visualizations while maintaining the native unstructured grid structure, ensuring we preserve the full resolution of our simulation data. Below we declare our desired projection.\n\nprojection = ccrs.Robinson()\n\n","type":"content","url":"/notebooks/recipes/e3sm#plotting","position":15},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl3":"Visualizing Different Time Steps","lvl2":"Plotting"},"type":"lvl3","url":"/notebooks/recipes/e3sm#visualizing-different-time-steps","position":16},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl3":"Visualizing Different Time Steps","lvl2":"Plotting"},"content":"The following visualization displays the Net Cloud Radiative Effect at two critical points in our model output: the first January (initial state) and the final month of January. This comparison allows us to examine both the baseline conditions and the evolved state of cloud-radiation interactions.\n\n(\n    uxds[\"netCRE\"]\n    .isel(time=0)\n    .plot(\n        projection=projection,\n        pixel_ratio=4.0,\n        coastline=True,\n        title=\"First Time Step (Year 0 Jan)\",\n    )\n    + uxds[\"netCRE\"]\n    .isel(time=61)\n    .plot(\n        projection=projection,\n        pixel_ratio=4.0,\n        coastline=True,\n        title=\"Final Time Step (Year 5 Jan)\",\n    )\n).cols(1)\n\n","type":"content","url":"/notebooks/recipes/e3sm#visualizing-different-time-steps","position":17},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl3":"Difference Analysis","lvl2":"Plotting"},"type":"lvl3","url":"/notebooks/recipes/e3sm#difference-analysis","position":18},{"hierarchy":{"lvl1":"E3SM Atmosphere","lvl3":"Difference Analysis","lvl2":"Plotting"},"content":"To quantify and visualize how the Net Cloud Radiative Effect evolved over the simulation period, we compute the difference between the final and initial months of January. This differential analysis highlights regions where cloud-radiation interactions have strengthened or weakened during the simulation.\n\n(uxds[\"netCRE\"].isel(time=61) - uxds[\"netCRE\"].isel(time=-0)).plot(\n    projection=projection, coastline=True, pixel_ratio=4.0, title=\"Change in NetCRE\"\n)","type":"content","url":"/notebooks/recipes/e3sm#difference-analysis","position":19},{"hierarchy":{"lvl1":"MPAS Atmosphere"},"type":"lvl1","url":"/notebooks/recipes/mpas-atmo","position":0},{"hierarchy":{"lvl1":"MPAS Atmosphere"},"content":"","type":"content","url":"/notebooks/recipes/mpas-atmo","position":1},{"hierarchy":{"lvl1":"MPAS Atmosphere"},"type":"lvl1","url":"/notebooks/recipes/mpas-atmo#mpas-atmosphere","position":2},{"hierarchy":{"lvl1":"MPAS Atmosphere"},"content":"This recipe demonstrates how to create visualizations using 30km MPAS Atmosphere model output. We’ll explore techniques for visualizing atmospheric variables on both the primal and dual MPAS grids, focusing on relative humidity and vorticity at the 200hPa pressure level.","type":"content","url":"/notebooks/recipes/mpas-atmo#mpas-atmosphere","position":3},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"Visualization Objectives"},"type":"lvl2","url":"/notebooks/recipes/mpas-atmo#visualization-objectives","position":4},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"Visualization Objectives"},"content":"This recipe will guide you through:\n\nCreating polygon plots using the MPAS primal grid to visualize relative humidity at 200hPa\n\nDeveloping polygon plots using the MPAS dual grid to visualize vorticity at 200hPa\n\nUnderstanding the differences between primal and dual grid visualizations in MPAS\n\nimport uxarray as ux\nimport cartopy.crs as ccrs\n\n","type":"content","url":"/notebooks/recipes/mpas-atmo#visualization-objectives","position":5},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"Relative Humidity"},"type":"lvl2","url":"/notebooks/recipes/mpas-atmo#relative-humidity","position":6},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"Relative Humidity"},"content":"For visualizing relative humidity, we use the Primal MPAS grid, which is composed of hexagons.\n\ngrid_path = \"../../meshfiles/x1.655362.grid.nc\"\ndata_path = \"../../meshfiles/x1.655362.data.nc\"\n\nuxds_primal = ux.open_dataset(grid_path, data_path)\nuxds_primal\n\nuxds_primal['relhum_200hPa'][0].plot(projection=ccrs.Robinson(), backend='matplotlib', pixel_ratio=4.0, features=['coastline'], width=1000, height=500, cmap='viridis', title=\"30km Relative Humidity (MPAS Primal Grid)\")\n\n","type":"content","url":"/notebooks/recipes/mpas-atmo#relative-humidity","position":7},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"Vorticity"},"type":"lvl2","url":"/notebooks/recipes/mpas-atmo#vorticity","position":8},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"Vorticity"},"content":"For visualizing relative humidity, we use the Dual MPAS grid, which is composed of triangles.\n\ngrid_path = \"../../meshfiles/x1.655362.grid.nc\"\ndata_path = \"../../meshfiles/x1.655362.data.nc\"\n\nuxds_dual = ux.open_dataset(grid_path, data_path, use_dual=True)\nuxds_dual['vorticity_200hPa']\n\nuxds_dual['vorticity_200hPa'][0].plot(projection=ccrs.Robinson(), rasterize=True, backend='matplotlib', pixel_ratio=4.0, features=['coastline'], width=1000, height=500, cmap='coolwarm', title=\"30km Vorticity (MPAS Dual Grid)\", clim=(-0.0001,0.0001))\n\n","type":"content","url":"/notebooks/recipes/mpas-atmo#vorticity","position":9},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"MPAS Dual & Primal Grids"},"type":"lvl2","url":"/notebooks/recipes/mpas-atmo#mpas-dual-primal-grids","position":10},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"MPAS Dual & Primal Grids"},"content":"The Model for Prediction Across Scales (MPAS) utilizes two complementary grid structures for atmospheric modeling: the primal grid and the dual grid. The primal grid consists of hexagonal cells that form the primary computational mesh, while the dual grid is composed of triangular cells that connect the centers of the primary hexagons.\n\nIn the primal grid structure, scalar quantities like relative humidity are naturally represented at the centers of the hexagonal cells. The dual grid, with its triangular elements, is particularly well-suited for vector quantities and derived fields such as vorticity.\n\nBelow, we visualize both grid structures to illustrate their complementary nature.\n\n(uxds_primal.uxgrid.subset.bounding_box(lon_bounds = (-1, 1), lat_bounds=(-0.5, 0.5)).plot(title=\"MPAS Primal Grid Structure\", ) + \n uxds_dual.uxgrid.subset.bounding_box(lon_bounds = (-1, 1), lat_bounds=(-0.5, 0.5)).plot(title=\"MPAS Dual Grid Structure\")).cols(1).opts(fig_size=200)\n\nThe visualization below demonstrates the intricate geometric relationship between MPAS primal and dual grids. By overlaying both grid structures, we can observe how the vertices of each hexagonal cell in the primal grid serve as the cell centers for the triangular elements of the dual grid. Conversely, the vertices of the triangular cells in the dual grid correspond to the centers of the hexagonal cells in the primal grid.\n\n(uxds_primal.uxgrid.subset.bounding_box(lon_bounds = (-1, 1), lat_bounds=(-0.5, 0.5)).plot() * \n uxds_dual.uxgrid.subset.bounding_box(lon_bounds = (-1, 1), lat_bounds=(-0.5, 0.5)).plot()).opts(fig_size=200, title=\"Primal & Dual Grid Together\")\n\n","type":"content","url":"/notebooks/recipes/mpas-atmo#mpas-dual-primal-grids","position":11},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"3.75km Visualization"},"type":"lvl2","url":"/notebooks/recipes/mpas-atmo#id-3-75km-visualization","position":12},{"hierarchy":{"lvl1":"MPAS Atmosphere","lvl2":"3.75km Visualization"},"content":"For another example of MPAS grid visualization, readers can refer to the UXarray \n\ndocumentation showcasing a 3.75km resolution grid\n\nThis example demonstrates MPAS visualization at a higher resolution compared to the 30km grid shown in this recipe.","type":"content","url":"/notebooks/recipes/mpas-atmo#id-3-75km-visualization","position":13},{"hierarchy":{"lvl1":"MPAS Ocean"},"type":"lvl1","url":"/notebooks/recipes/mpas-ocean","position":0},{"hierarchy":{"lvl1":"MPAS Ocean"},"content":"","type":"content","url":"/notebooks/recipes/mpas-ocean","position":1},{"hierarchy":{"lvl1":"MPAS Ocean"},"type":"lvl1","url":"/notebooks/recipes/mpas-ocean#mpas-ocean","position":2},{"hierarchy":{"lvl1":"MPAS Ocean"},"content":"In this recipe, you will learn how to create visualizations of global ocean depth data using MPAS-Ocean model output. The recipe includes techniques for both global-scale visualization and regional analysis, with a specific focus on the Gulf of Mexico region.","type":"content","url":"/notebooks/recipes/mpas-ocean#mpas-ocean","position":3},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Visualization Objectives"},"type":"lvl2","url":"/notebooks/recipes/mpas-ocean#visualization-objectives","position":4},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Visualization Objectives"},"content":"This recipe will guide you through creating:\n\nGlobal ocean visualizations using the Robinson projection with raster-based plotting\n\nRegional depth analysis of the Gulf of Mexico using vector polygons\n\nimport cartopy.crs as ccrs\nimport uxarray as ux\n\ngrid_path = \"../../meshfiles/oQU120.grid.nc\"\ndata_path = \"../../meshfiles/oQU120.data.nc\"\n\nuxds = ux.open_dataset(grid_path, data_path)\n\n","type":"content","url":"/notebooks/recipes/mpas-ocean#visualization-objectives","position":5},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Data Preparation"},"type":"lvl2","url":"/notebooks/recipes/mpas-ocean#data-preparation","position":6},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Data Preparation"},"content":"","type":"content","url":"/notebooks/recipes/mpas-ocean#data-preparation","position":7},{"hierarchy":{"lvl1":"MPAS Ocean","lvl3":"Global Ocean Data","lvl2":"Data Preparation"},"type":"lvl3","url":"/notebooks/recipes/mpas-ocean#global-ocean-data","position":8},{"hierarchy":{"lvl1":"MPAS Ocean","lvl3":"Global Ocean Data","lvl2":"Data Preparation"},"content":"The global MPAS-Ocean grid data requires no preprocessing for our visualization purposes, as it already encompasses the complete global domain.\n\nbottom_depth = uxds[\"bottomDepth\"]\nbottom_depth.uxgrid.n_face\n\n","type":"content","url":"/notebooks/recipes/mpas-ocean#global-ocean-data","position":9},{"hierarchy":{"lvl1":"MPAS Ocean","lvl3":"Regional Focus: Gulf of Mexico","lvl2":"Data Preparation"},"type":"lvl3","url":"/notebooks/recipes/mpas-ocean#regional-focus-gulf-of-mexico","position":10},{"hierarchy":{"lvl1":"MPAS Ocean","lvl3":"Regional Focus: Gulf of Mexico","lvl2":"Data Preparation"},"content":"To create a detailed regional visualization of the Gulf of Mexico, we’ll perform a spatial subset of our global data. By applying a bounding circle operation centered at 90°W longitude and 25°N latitude with a 9-degree radius, we can focus our analysis specifically on the Gulf region. This subsetting approach significantly reduces the computational demands of our visualization routines.\n\nbottom_depth_gulf = bottom_depth.subset.bounding_circle((-90.0, 25.0), r=9)\nbottom_depth_gulf.uxgrid.n_face\n\n","type":"content","url":"/notebooks/recipes/mpas-ocean#regional-focus-gulf-of-mexico","position":11},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Global Ocean Depth Visualization"},"type":"lvl2","url":"/notebooks/recipes/mpas-ocean#global-ocean-depth-visualization","position":12},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Global Ocean Depth Visualization"},"content":"For our global visualization, we selected the Robinson projection combined with raster plotting to effectively display worldwide ocean depth data. The 4.0 pixel ratio setting ensures clear resolution while maintaining efficient performance across the entire global domain.\n\nbottom_depth.plot.polygons(\n    rasterize=True,\n    backend=\"matplotlib\",\n    projection=ccrs.Robinson(),\n    coastline=\"110m\",\n    cmap=\"Blues\",\n    width=1000,\n    pixel_ratio=4.0,\n    title=\"Global Ocean Depth\",\n)\n\n","type":"content","url":"/notebooks/recipes/mpas-ocean#global-ocean-depth-visualization","position":13},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Regional Visualization: Gulf of Mexico"},"type":"lvl2","url":"/notebooks/recipes/mpas-ocean#regional-visualization-gulf-of-mexico","position":14},{"hierarchy":{"lvl1":"MPAS Ocean","lvl2":"Regional Visualization: Gulf of Mexico"},"content":"For our detailed analysis of the Gulf of Mexico region, we transition to a vector-based polygon visualization approach. This shift from our global visualization strategy is driven by the reduced computational demands of our regional subset, which contains only 164 faces. Vector polygons offer several advantages at this scale, including precise boundary representation and enhanced detail visualization.\n\nbottom_depth_gulf.plot(\n    rasterize=False,\n    backend=\"matplotlib\",\n    projection=ccrs.Robinson(),\n    features=[\"states\", \"coastline\"],\n    cmap=\"Blues\",\n    width=500,\n    title=\"Gulf of Mexico Depth\",\n)","type":"content","url":"/notebooks/recipes/mpas-ocean#regional-visualization-gulf-of-mexico","position":15},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in this Project Pythia Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1}]}